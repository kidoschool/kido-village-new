{"ast":null,"code":"/*!\n * skrollr core\n *\n * Alexander Prinzhorn - https://github.com/Prinzhorn/skrollr\n *\n * Free to use under terms of MIT license\n */\n(function (window, document, undefined) {\n  'use strict';\n  /*\n   * Global api.\n   */\n\n  var skrollr = {\n    get: function () {\n      return _instance;\n    },\n    //Main entry point.\n    init: function (options) {\n      return _instance || new Skrollr(options);\n    },\n    VERSION: '0.6.30'\n  }; //Minify optimization.\n\n  var hasProp = Object.prototype.hasOwnProperty;\n  var Math = window.Math;\n  var getStyle = window.getComputedStyle; //They will be filled when skrollr gets initialized.\n\n  var documentElement;\n  var body;\n  var EVENT_TOUCHSTART = 'touchstart';\n  var EVENT_TOUCHMOVE = 'touchmove';\n  var EVENT_TOUCHCANCEL = 'touchcancel';\n  var EVENT_TOUCHEND = 'touchend';\n  var SKROLLABLE_CLASS = 'skrollable';\n  var SKROLLABLE_BEFORE_CLASS = SKROLLABLE_CLASS + '-before';\n  var SKROLLABLE_BETWEEN_CLASS = SKROLLABLE_CLASS + '-between';\n  var SKROLLABLE_AFTER_CLASS = SKROLLABLE_CLASS + '-after';\n  var SKROLLR_CLASS = 'skrollr';\n  var NO_SKROLLR_CLASS = 'no-' + SKROLLR_CLASS;\n  var SKROLLR_DESKTOP_CLASS = SKROLLR_CLASS + '-desktop';\n  var SKROLLR_MOBILE_CLASS = SKROLLR_CLASS + '-mobile';\n  var DEFAULT_EASING = 'linear';\n  var DEFAULT_DURATION = 1000; //ms\n\n  var DEFAULT_MOBILE_DECELERATION = 0.004; //pixel/msÂ²\n\n  var DEFAULT_SKROLLRBODY = 'skrollr-body';\n  var DEFAULT_SMOOTH_SCROLLING_DURATION = 200; //ms\n\n  var ANCHOR_START = 'start';\n  var ANCHOR_END = 'end';\n  var ANCHOR_CENTER = 'center';\n  var ANCHOR_BOTTOM = 'bottom'; //The property which will be added to the DOM element to hold the ID of the skrollable.\n\n  var SKROLLABLE_ID_DOM_PROPERTY = '___skrollable_id';\n  var rxTouchIgnoreTags = /^(?:input|textarea|button|select)$/i;\n  var rxTrim = /^\\s+|\\s+$/g; //Find all data-attributes. data-[_constant]-[offset]-[anchor]-[anchor].\n\n  var rxKeyframeAttribute = /^data(?:-(_\\w+))?(?:-?(-?\\d*\\.?\\d+p?))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/;\n  var rxPropValue = /\\s*(@?[\\w\\-\\[\\]]+)\\s*:\\s*(.+?)\\s*(?:;|$)/gi; //Easing function names follow the property in square brackets.\n\n  var rxPropEasing = /^(@?[a-z\\-]+)\\[(\\w+)\\]$/;\n  var rxCamelCase = /-([a-z0-9_])/g;\n\n  var rxCamelCaseFn = function (str, letter) {\n    return letter.toUpperCase();\n  }; //Numeric values with optional sign.\n\n\n  var rxNumericValue = /[\\-+]?[\\d]*\\.?[\\d]+/g; //Used to replace occurences of {?} with a number.\n\n  var rxInterpolateString = /\\{\\?\\}/g; //Finds rgb(a) colors, which don't use the percentage notation.\n\n  var rxRGBAIntegerColor = /rgba?\\(\\s*-?\\d+\\s*,\\s*-?\\d+\\s*,\\s*-?\\d+/g; //Finds all gradients.\n\n  var rxGradient = /[a-z\\-]+-gradient/g; //Vendor prefix. Will be set once skrollr gets initialized.\n\n  var theCSSPrefix = '';\n  var theDashedCSSPrefix = ''; //Will be called once (when skrollr gets initialized).\n\n  var detectCSSPrefix = function () {\n    //Only relevant prefixes. May be extended.\n    //Could be dangerous if there will ever be a CSS property which actually starts with \"ms\". Don't hope so.\n    var rxPrefixes = /^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/; //Detect prefix for current browser by finding the first property using a prefix.\n\n    if (!getStyle) {\n      return;\n    }\n\n    var style = getStyle(body, null);\n\n    for (var k in style) {\n      //We check the key and if the key is a number, we check the value as well, because safari's getComputedStyle returns some weird array-like thingy.\n      theCSSPrefix = k.match(rxPrefixes) || +k == k && style[k].match(rxPrefixes);\n\n      if (theCSSPrefix) {\n        break;\n      }\n    } //Did we even detect a prefix?\n\n\n    if (!theCSSPrefix) {\n      theCSSPrefix = theDashedCSSPrefix = '';\n      return;\n    }\n\n    theCSSPrefix = theCSSPrefix[0]; //We could have detected either a dashed prefix or this camelCaseish-inconsistent stuff.\n\n    if (theCSSPrefix.slice(0, 1) === '-') {\n      theDashedCSSPrefix = theCSSPrefix; //There's no logic behind these. Need a look up.\n\n      theCSSPrefix = {\n        '-webkit-': 'webkit',\n        '-moz-': 'Moz',\n        '-ms-': 'ms',\n        '-o-': 'O'\n      }[theCSSPrefix];\n    } else {\n      theDashedCSSPrefix = '-' + theCSSPrefix.toLowerCase() + '-';\n    }\n  };\n\n  var polyfillRAF = function () {\n    var requestAnimFrame = window.requestAnimationFrame || window[theCSSPrefix.toLowerCase() + 'RequestAnimationFrame'];\n\n    var lastTime = _now();\n\n    if (_isMobile || !requestAnimFrame) {\n      requestAnimFrame = function (callback) {\n        //How long did it take to render?\n        var deltaTime = _now() - lastTime;\n        var delay = Math.max(0, 1000 / 60 - deltaTime);\n        return window.setTimeout(function () {\n          lastTime = _now();\n          callback();\n        }, delay);\n      };\n    }\n\n    return requestAnimFrame;\n  };\n\n  var polyfillCAF = function () {\n    var cancelAnimFrame = window.cancelAnimationFrame || window[theCSSPrefix.toLowerCase() + 'CancelAnimationFrame'];\n\n    if (_isMobile || !cancelAnimFrame) {\n      cancelAnimFrame = function (timeout) {\n        return window.clearTimeout(timeout);\n      };\n    }\n\n    return cancelAnimFrame;\n  }; //Built-in easing functions.\n\n\n  var easings = {\n    begin: function () {\n      return 0;\n    },\n    end: function () {\n      return 1;\n    },\n    linear: function (p) {\n      return p;\n    },\n    quadratic: function (p) {\n      return p * p;\n    },\n    cubic: function (p) {\n      return p * p * p;\n    },\n    swing: function (p) {\n      return -Math.cos(p * Math.PI) / 2 + 0.5;\n    },\n    sqrt: function (p) {\n      return Math.sqrt(p);\n    },\n    outCubic: function (p) {\n      return Math.pow(p - 1, 3) + 1;\n    },\n    //see https://www.desmos.com/calculator/tbr20s8vd2 for how I did this\n    bounce: function (p) {\n      var a;\n\n      if (p <= 0.5083) {\n        a = 3;\n      } else if (p <= 0.8489) {\n        a = 9;\n      } else if (p <= 0.96208) {\n        a = 27;\n      } else if (p <= 0.99981) {\n        a = 91;\n      } else {\n        return 1;\n      }\n\n      return 1 - Math.abs(3 * Math.cos(p * a * 1.028) / a);\n    }\n  };\n  /**\n   * Constructor.\n   */\n\n  function Skrollr(options) {\n    documentElement = document.documentElement;\n    body = document.body;\n    detectCSSPrefix();\n    _instance = this;\n    options = options || {};\n    _constants = options.constants || {}; //We allow defining custom easings or overwrite existing.\n\n    if (options.easing) {\n      for (var e in options.easing) {\n        easings[e] = options.easing[e];\n      }\n    }\n\n    _edgeStrategy = options.edgeStrategy || 'set';\n    _listeners = {\n      //Function to be called right before rendering.\n      beforerender: options.beforerender,\n      //Function to be called right after finishing rendering.\n      render: options.render,\n      //Function to be called whenever an element with the `data-emit-events` attribute passes a keyframe.\n      keyframe: options.keyframe\n    }; //forceHeight is true by default\n\n    _forceHeight = options.forceHeight !== false;\n\n    if (_forceHeight) {\n      _scale = options.scale || 1;\n    }\n\n    _mobileDeceleration = options.mobileDeceleration || DEFAULT_MOBILE_DECELERATION;\n    _smoothScrollingEnabled = options.smoothScrolling !== false;\n    _smoothScrollingDuration = options.smoothScrollingDuration || DEFAULT_SMOOTH_SCROLLING_DURATION; //Dummy object. Will be overwritten in the _render method when smooth scrolling is calculated.\n\n    _smoothScrolling = {\n      targetTop: _instance.getScrollTop()\n    }; //A custom check function may be passed.\n\n    _isMobile = (options.mobileCheck || function () {\n      return /Android|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent || navigator.vendor || window.opera);\n    })();\n\n    if (_isMobile) {\n      _skrollrBody = document.getElementById(options.skrollrBody || DEFAULT_SKROLLRBODY); //Detect 3d transform if there's a skrollr-body (only needed for #skrollr-body).\n\n      if (_skrollrBody) {\n        _detect3DTransforms();\n      }\n\n      _initMobile();\n\n      _updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_MOBILE_CLASS], [NO_SKROLLR_CLASS]);\n    } else {\n      _updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS], [NO_SKROLLR_CLASS]);\n    } //Triggers parsing of elements and a first reflow.\n\n\n    _instance.refresh();\n\n    _addEvent(window, 'resize orientationchange', function () {\n      var width = documentElement.clientWidth;\n      var height = documentElement.clientHeight; //Only reflow if the size actually changed (#271).\n\n      if (height !== _lastViewportHeight || width !== _lastViewportWidth) {\n        _lastViewportHeight = height;\n        _lastViewportWidth = width;\n        _requestReflow = true;\n      }\n    });\n\n    var requestAnimFrame = polyfillRAF(); //Let's go.\n\n    (function animloop() {\n      _render();\n\n      _animFrame = requestAnimFrame(animloop);\n    })();\n\n    return _instance;\n  }\n  /**\n   * (Re)parses some or all elements.\n   */\n\n\n  Skrollr.prototype.refresh = function (elements) {\n    var elementIndex;\n    var elementsLength;\n    var ignoreID = false; //Completely reparse anything without argument.\n\n    if (elements === undefined) {\n      //Ignore that some elements may already have a skrollable ID.\n      ignoreID = true;\n      _skrollables = [];\n      _skrollableIdCounter = 0;\n      elements = document.getElementsByTagName('*');\n    } else if (elements.length === undefined) {\n      //We also accept a single element as parameter.\n      elements = [elements];\n    }\n\n    elementIndex = 0;\n    elementsLength = elements.length;\n\n    for (; elementIndex < elementsLength; elementIndex++) {\n      var el = elements[elementIndex];\n      var anchorTarget = el;\n      var keyFrames = []; //If this particular element should be smooth scrolled.\n\n      var smoothScrollThis = _smoothScrollingEnabled; //The edge strategy for this particular element.\n\n      var edgeStrategy = _edgeStrategy; //If this particular element should emit keyframe events.\n\n      var emitEvents = false; //If we're reseting the counter, remove any old element ids that may be hanging around.\n\n      if (ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {\n        delete el[SKROLLABLE_ID_DOM_PROPERTY];\n      }\n\n      if (!el.attributes) {\n        continue;\n      } //Iterate over all attributes and search for key frame attributes.\n\n\n      var attributeIndex = 0;\n      var attributesLength = el.attributes.length;\n\n      for (; attributeIndex < attributesLength; attributeIndex++) {\n        var attr = el.attributes[attributeIndex];\n\n        if (attr.name === 'data-anchor-target') {\n          anchorTarget = document.querySelector(attr.value);\n\n          if (anchorTarget === null) {\n            throw 'Unable to find anchor target \"' + attr.value + '\"';\n          }\n\n          continue;\n        } //Global smooth scrolling can be overridden by the element attribute.\n\n\n        if (attr.name === 'data-smooth-scrolling') {\n          smoothScrollThis = attr.value !== 'off';\n          continue;\n        } //Global edge strategy can be overridden by the element attribute.\n\n\n        if (attr.name === 'data-edge-strategy') {\n          edgeStrategy = attr.value;\n          continue;\n        } //Is this element tagged with the `data-emit-events` attribute?\n\n\n        if (attr.name === 'data-emit-events') {\n          emitEvents = true;\n          continue;\n        }\n\n        var match = attr.name.match(rxKeyframeAttribute);\n\n        if (match === null) {\n          continue;\n        }\n\n        var kf = {\n          props: attr.value,\n          //Point back to the element as well.\n          element: el,\n          //The name of the event which this keyframe will fire, if emitEvents is\n          eventType: attr.name.replace(rxCamelCase, rxCamelCaseFn)\n        };\n        keyFrames.push(kf);\n        var constant = match[1];\n\n        if (constant) {\n          //Strip the underscore prefix.\n          kf.constant = constant.substr(1);\n        } //Get the key frame offset.\n\n\n        var offset = match[2]; //Is it a percentage offset?\n\n        if (/p$/.test(offset)) {\n          kf.isPercentage = true;\n          kf.offset = (offset.slice(0, -1) | 0) / 100;\n        } else {\n          kf.offset = offset | 0;\n        }\n\n        var anchor1 = match[3]; //If second anchor is not set, the first will be taken for both.\n\n        var anchor2 = match[4] || anchor1; //\"absolute\" (or \"classic\") mode, where numbers mean absolute scroll offset.\n\n        if (!anchor1 || anchor1 === ANCHOR_START || anchor1 === ANCHOR_END) {\n          kf.mode = 'absolute'; //data-end needs to be calculated after all key frames are known.\n\n          if (anchor1 === ANCHOR_END) {\n            kf.isEnd = true;\n          } else if (!kf.isPercentage) {\n            //For data-start we can already set the key frame w/o calculations.\n            //#59: \"scale\" options should only affect absolute mode.\n            kf.offset = kf.offset * _scale;\n          }\n        } //\"relative\" mode, where numbers are relative to anchors.\n        else {\n            kf.mode = 'relative';\n            kf.anchors = [anchor1, anchor2];\n          }\n      } //Does this element have key frames?\n\n\n      if (!keyFrames.length) {\n        continue;\n      } //Will hold the original style and class attributes before we controlled the element (see #80).\n\n\n      var styleAttr, classAttr;\n      var id;\n\n      if (!ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {\n        //We already have this element under control. Grab the corresponding skrollable id.\n        id = el[SKROLLABLE_ID_DOM_PROPERTY];\n        styleAttr = _skrollables[id].styleAttr;\n        classAttr = _skrollables[id].classAttr;\n      } else {\n        //It's an unknown element. Asign it a new skrollable id.\n        id = el[SKROLLABLE_ID_DOM_PROPERTY] = _skrollableIdCounter++;\n        styleAttr = el.style.cssText;\n        classAttr = _getClass(el);\n      }\n\n      _skrollables[id] = {\n        element: el,\n        styleAttr: styleAttr,\n        classAttr: classAttr,\n        anchorTarget: anchorTarget,\n        keyFrames: keyFrames,\n        smoothScrolling: smoothScrollThis,\n        edgeStrategy: edgeStrategy,\n        emitEvents: emitEvents,\n        lastFrameIndex: -1\n      };\n\n      _updateClass(el, [SKROLLABLE_CLASS], []);\n    } //Reflow for the first time.\n\n\n    _reflow(); //Now that we got all key frame numbers right, actually parse the properties.\n\n\n    elementIndex = 0;\n    elementsLength = elements.length;\n\n    for (; elementIndex < elementsLength; elementIndex++) {\n      var sk = _skrollables[elements[elementIndex][SKROLLABLE_ID_DOM_PROPERTY]];\n\n      if (sk === undefined) {\n        continue;\n      } //Parse the property string to objects\n\n\n      _parseProps(sk); //Fill key frames with missing properties from left and right\n\n\n      _fillProps(sk);\n    }\n\n    return _instance;\n  };\n  /**\n   * Transform \"relative\" mode to \"absolute\" mode.\n   * That is, calculate anchor position and offset of element.\n   */\n\n\n  Skrollr.prototype.relativeToAbsolute = function (element, viewportAnchor, elementAnchor) {\n    var viewportHeight = documentElement.clientHeight;\n    var box = element.getBoundingClientRect();\n    var absolute = box.top; //#100: IE doesn't supply \"height\" with getBoundingClientRect.\n\n    var boxHeight = box.bottom - box.top;\n\n    if (viewportAnchor === ANCHOR_BOTTOM) {\n      absolute -= viewportHeight;\n    } else if (viewportAnchor === ANCHOR_CENTER) {\n      absolute -= viewportHeight / 2;\n    }\n\n    if (elementAnchor === ANCHOR_BOTTOM) {\n      absolute += boxHeight;\n    } else if (elementAnchor === ANCHOR_CENTER) {\n      absolute += boxHeight / 2;\n    } //Compensate scrolling since getBoundingClientRect is relative to viewport.\n\n\n    absolute += _instance.getScrollTop();\n    return absolute + 0.5 | 0;\n  };\n  /**\n   * Animates scroll top to new position.\n   */\n\n\n  Skrollr.prototype.animateTo = function (top, options) {\n    options = options || {};\n\n    var now = _now();\n\n    var scrollTop = _instance.getScrollTop();\n\n    var duration = options.duration === undefined ? DEFAULT_DURATION : options.duration; //Setting this to a new value will automatically cause the current animation to stop, if any.\n\n    _scrollAnimation = {\n      startTop: scrollTop,\n      topDiff: top - scrollTop,\n      targetTop: top,\n      duration: duration,\n      startTime: now,\n      endTime: now + duration,\n      easing: easings[options.easing || DEFAULT_EASING],\n      done: options.done\n    }; //Don't queue the animation if there's nothing to animate.\n\n    if (!_scrollAnimation.topDiff) {\n      if (_scrollAnimation.done) {\n        _scrollAnimation.done.call(_instance, false);\n      }\n\n      _scrollAnimation = undefined;\n    }\n\n    return _instance;\n  };\n  /**\n   * Stops animateTo animation.\n   */\n\n\n  Skrollr.prototype.stopAnimateTo = function () {\n    if (_scrollAnimation && _scrollAnimation.done) {\n      _scrollAnimation.done.call(_instance, true);\n    }\n\n    _scrollAnimation = undefined;\n  };\n  /**\n   * Returns if an animation caused by animateTo is currently running.\n   */\n\n\n  Skrollr.prototype.isAnimatingTo = function () {\n    return !!_scrollAnimation;\n  };\n\n  Skrollr.prototype.isMobile = function () {\n    return _isMobile;\n  };\n\n  Skrollr.prototype.setScrollTop = function (top, force) {\n    _forceRender = force === true;\n\n    if (_isMobile) {\n      _mobileOffset = Math.min(Math.max(top, 0), _maxKeyFrame);\n    } else {\n      window.scrollTo(0, top);\n    }\n\n    return _instance;\n  };\n\n  Skrollr.prototype.getScrollTop = function () {\n    if (_isMobile) {\n      return _mobileOffset;\n    } else {\n      return window.pageYOffset || documentElement.scrollTop || body.scrollTop || 0;\n    }\n  };\n\n  Skrollr.prototype.getMaxScrollTop = function () {\n    return _maxKeyFrame;\n  };\n\n  Skrollr.prototype.on = function (name, fn) {\n    _listeners[name] = fn;\n    return _instance;\n  };\n\n  Skrollr.prototype.off = function (name) {\n    delete _listeners[name];\n    return _instance;\n  };\n\n  Skrollr.prototype.destroy = function () {\n    var cancelAnimFrame = polyfillCAF();\n    cancelAnimFrame(_animFrame);\n\n    _removeAllEvents();\n\n    _updateClass(documentElement, [NO_SKROLLR_CLASS], [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS, SKROLLR_MOBILE_CLASS]);\n\n    var skrollableIndex = 0;\n    var skrollablesLength = _skrollables.length;\n\n    for (; skrollableIndex < skrollablesLength; skrollableIndex++) {\n      _reset(_skrollables[skrollableIndex].element);\n    }\n\n    documentElement.style.overflow = body.style.overflow = '';\n    documentElement.style.height = body.style.height = '';\n\n    if (_skrollrBody) {\n      skrollr.setStyle(_skrollrBody, 'transform', 'none');\n    }\n\n    _instance = undefined;\n    _skrollrBody = undefined;\n    _listeners = undefined;\n    _forceHeight = undefined;\n    _maxKeyFrame = 0;\n    _scale = 1;\n    _constants = undefined;\n    _mobileDeceleration = undefined;\n    _direction = 'down';\n    _lastTop = -1;\n    _lastViewportWidth = 0;\n    _lastViewportHeight = 0;\n    _requestReflow = false;\n    _scrollAnimation = undefined;\n    _smoothScrollingEnabled = undefined;\n    _smoothScrollingDuration = undefined;\n    _smoothScrolling = undefined;\n    _forceRender = undefined;\n    _skrollableIdCounter = 0;\n    _edgeStrategy = undefined;\n    _isMobile = false;\n    _mobileOffset = 0;\n    _translateZ = undefined;\n  };\n  /*\n  \tPrivate methods.\n  */\n\n\n  var _initMobile = function () {\n    var initialElement;\n    var initialTouchY;\n    var initialTouchX;\n    var currentElement;\n    var currentTouchY;\n    var currentTouchX;\n    var lastTouchY;\n    var deltaY;\n    var initialTouchTime;\n    var currentTouchTime;\n    var lastTouchTime;\n    var deltaTime;\n\n    _addEvent(documentElement, [EVENT_TOUCHSTART, EVENT_TOUCHMOVE, EVENT_TOUCHCANCEL, EVENT_TOUCHEND].join(' '), function (e) {\n      var touch = e.changedTouches[0];\n      currentElement = e.target; //We don't want text nodes.\n\n      while (currentElement.nodeType === 3) {\n        currentElement = currentElement.parentNode;\n      }\n\n      currentTouchY = touch.clientY;\n      currentTouchX = touch.clientX;\n      currentTouchTime = e.timeStamp;\n\n      if (!rxTouchIgnoreTags.test(currentElement.tagName)) {\n        e.preventDefault();\n      }\n\n      switch (e.type) {\n        case EVENT_TOUCHSTART:\n          //The last element we tapped on.\n          if (initialElement) {\n            initialElement.blur();\n          }\n\n          _instance.stopAnimateTo();\n\n          initialElement = currentElement;\n          initialTouchY = lastTouchY = currentTouchY;\n          initialTouchX = currentTouchX;\n          initialTouchTime = currentTouchTime;\n          break;\n\n        case EVENT_TOUCHMOVE:\n          //Prevent default event on touchIgnore elements in case they don't have focus yet.\n          if (rxTouchIgnoreTags.test(currentElement.tagName) && document.activeElement !== currentElement) {\n            e.preventDefault();\n          }\n\n          deltaY = currentTouchY - lastTouchY;\n          deltaTime = currentTouchTime - lastTouchTime;\n\n          _instance.setScrollTop(_mobileOffset - deltaY, true);\n\n          lastTouchY = currentTouchY;\n          lastTouchTime = currentTouchTime;\n          break;\n\n        default:\n        case EVENT_TOUCHCANCEL:\n        case EVENT_TOUCHEND:\n          var distanceY = initialTouchY - currentTouchY;\n          var distanceX = initialTouchX - currentTouchX;\n          var distance2 = distanceX * distanceX + distanceY * distanceY; //Check if it was more like a tap (moved less than 7px).\n\n          if (distance2 < 49) {\n            if (!rxTouchIgnoreTags.test(initialElement.tagName)) {\n              initialElement.focus(); //It was a tap, click the element.\n\n              var clickEvent = document.createEvent('MouseEvents');\n              clickEvent.initMouseEvent('click', true, true, e.view, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);\n              initialElement.dispatchEvent(clickEvent);\n            }\n\n            return;\n          }\n\n          initialElement = undefined;\n          var speed = deltaY / deltaTime; //Cap speed at 3 pixel/ms.\n\n          speed = Math.max(Math.min(speed, 3), -3);\n          var duration = Math.abs(speed / _mobileDeceleration);\n          var targetOffset = speed * duration + 0.5 * _mobileDeceleration * duration * duration;\n          var targetTop = _instance.getScrollTop() - targetOffset; //Relative duration change for when scrolling above bounds.\n\n          var targetRatio = 0; //Change duration proportionally when scrolling would leave bounds.\n\n          if (targetTop > _maxKeyFrame) {\n            targetRatio = (_maxKeyFrame - targetTop) / targetOffset;\n            targetTop = _maxKeyFrame;\n          } else if (targetTop < 0) {\n            targetRatio = -targetTop / targetOffset;\n            targetTop = 0;\n          }\n\n          duration = duration * (1 - targetRatio);\n\n          _instance.animateTo(targetTop + 0.5 | 0, {\n            easing: 'outCubic',\n            duration: duration\n          });\n\n          break;\n      }\n    }); //Just in case there has already been some native scrolling, reset it.\n\n\n    window.scrollTo(0, 0);\n    documentElement.style.overflow = body.style.overflow = 'hidden';\n  };\n  /**\n   * Updates key frames which depend on others / need to be updated on resize.\n   * That is \"end\" in \"absolute\" mode and all key frames in \"relative\" mode.\n   * Also handles constants, because they may change on resize.\n   */\n\n\n  var _updateDependentKeyFrames = function () {\n    var viewportHeight = documentElement.clientHeight;\n\n    var processedConstants = _processConstants();\n\n    var skrollable;\n    var element;\n    var anchorTarget;\n    var keyFrames;\n    var keyFrameIndex;\n    var keyFramesLength;\n    var kf;\n    var skrollableIndex;\n    var skrollablesLength;\n    var offset;\n    var constantValue; //First process all relative-mode elements and find the max key frame.\n\n    skrollableIndex = 0;\n    skrollablesLength = _skrollables.length;\n\n    for (; skrollableIndex < skrollablesLength; skrollableIndex++) {\n      skrollable = _skrollables[skrollableIndex];\n      element = skrollable.element;\n      anchorTarget = skrollable.anchorTarget;\n      keyFrames = skrollable.keyFrames;\n      keyFrameIndex = 0;\n      keyFramesLength = keyFrames.length;\n\n      for (; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n        kf = keyFrames[keyFrameIndex];\n        offset = kf.offset;\n        constantValue = processedConstants[kf.constant] || 0;\n        kf.frame = offset;\n\n        if (kf.isPercentage) {\n          //Convert the offset to percentage of the viewport height.\n          offset = offset * viewportHeight; //Absolute + percentage mode.\n\n          kf.frame = offset;\n        }\n\n        if (kf.mode === 'relative') {\n          _reset(element);\n\n          kf.frame = _instance.relativeToAbsolute(anchorTarget, kf.anchors[0], kf.anchors[1]) - offset;\n\n          _reset(element, true);\n        }\n\n        kf.frame += constantValue; //Only search for max key frame when forceHeight is enabled.\n\n        if (_forceHeight) {\n          //Find the max key frame, but don't use one of the data-end ones for comparison.\n          if (!kf.isEnd && kf.frame > _maxKeyFrame) {\n            _maxKeyFrame = kf.frame;\n          }\n        }\n      }\n    } //#133: The document can be larger than the maxKeyFrame we found.\n\n\n    _maxKeyFrame = Math.max(_maxKeyFrame, _getDocumentHeight()); //Now process all data-end keyframes.\n\n    skrollableIndex = 0;\n    skrollablesLength = _skrollables.length;\n\n    for (; skrollableIndex < skrollablesLength; skrollableIndex++) {\n      skrollable = _skrollables[skrollableIndex];\n      keyFrames = skrollable.keyFrames;\n      keyFrameIndex = 0;\n      keyFramesLength = keyFrames.length;\n\n      for (; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n        kf = keyFrames[keyFrameIndex];\n        constantValue = processedConstants[kf.constant] || 0;\n\n        if (kf.isEnd) {\n          kf.frame = _maxKeyFrame - kf.offset + constantValue;\n        }\n      }\n\n      skrollable.keyFrames.sort(_keyFrameComparator);\n    }\n  };\n  /**\n   * Calculates and sets the style properties for the element at the given frame.\n   * @param fakeFrame The frame to render at when smooth scrolling is enabled.\n   * @param actualFrame The actual frame we are at.\n   */\n\n\n  var _calcSteps = function (fakeFrame, actualFrame) {\n    //Iterate over all skrollables.\n    var skrollableIndex = 0;\n    var skrollablesLength = _skrollables.length;\n\n    for (; skrollableIndex < skrollablesLength; skrollableIndex++) {\n      var skrollable = _skrollables[skrollableIndex];\n      var element = skrollable.element;\n      var frame = skrollable.smoothScrolling ? fakeFrame : actualFrame;\n      var frames = skrollable.keyFrames;\n      var framesLength = frames.length;\n      var firstFrame = frames[0];\n      var lastFrame = frames[frames.length - 1];\n      var beforeFirst = frame < firstFrame.frame;\n      var afterLast = frame > lastFrame.frame;\n      var firstOrLastFrame = beforeFirst ? firstFrame : lastFrame;\n      var emitEvents = skrollable.emitEvents;\n      var lastFrameIndex = skrollable.lastFrameIndex;\n      var key;\n      var value; //If we are before/after the first/last frame, set the styles according to the given edge strategy.\n\n      if (beforeFirst || afterLast) {\n        //Check if we already handled this edge case last time.\n        //Note: using setScrollTop it's possible that we jumped from one edge to the other.\n        if (beforeFirst && skrollable.edge === -1 || afterLast && skrollable.edge === 1) {\n          continue;\n        } //Add the skrollr-before or -after class.\n\n\n        if (beforeFirst) {\n          _updateClass(element, [SKROLLABLE_BEFORE_CLASS], [SKROLLABLE_AFTER_CLASS, SKROLLABLE_BETWEEN_CLASS]); //This handles the special case where we exit the first keyframe.\n\n\n          if (emitEvents && lastFrameIndex > -1) {\n            _emitEvent(element, firstFrame.eventType, _direction);\n\n            skrollable.lastFrameIndex = -1;\n          }\n        } else {\n          _updateClass(element, [SKROLLABLE_AFTER_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_BETWEEN_CLASS]); //This handles the special case where we exit the last keyframe.\n\n\n          if (emitEvents && lastFrameIndex < framesLength) {\n            _emitEvent(element, lastFrame.eventType, _direction);\n\n            skrollable.lastFrameIndex = framesLength;\n          }\n        } //Remember that we handled the edge case (before/after the first/last keyframe).\n\n\n        skrollable.edge = beforeFirst ? -1 : 1;\n\n        switch (skrollable.edgeStrategy) {\n          case 'reset':\n            _reset(element);\n\n            continue;\n\n          case 'ease':\n            //Handle this case like it would be exactly at first/last keyframe and just pass it on.\n            frame = firstOrLastFrame.frame;\n            break;\n\n          default:\n          case 'set':\n            var props = firstOrLastFrame.props;\n\n            for (key in props) {\n              if (hasProp.call(props, key)) {\n                value = _interpolateString(props[key].value); //Set style or attribute.\n\n                if (key.indexOf('@') === 0) {\n                  element.setAttribute(key.substr(1), value);\n                } else {\n                  skrollr.setStyle(element, key, value);\n                }\n              }\n            }\n\n            continue;\n        }\n      } else {\n        //Did we handle an edge last time?\n        if (skrollable.edge !== 0) {\n          _updateClass(element, [SKROLLABLE_CLASS, SKROLLABLE_BETWEEN_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_AFTER_CLASS]);\n\n          skrollable.edge = 0;\n        }\n      } //Find out between which two key frames we are right now.\n\n\n      var keyFrameIndex = 0;\n\n      for (; keyFrameIndex < framesLength - 1; keyFrameIndex++) {\n        if (frame >= frames[keyFrameIndex].frame && frame <= frames[keyFrameIndex + 1].frame) {\n          var left = frames[keyFrameIndex];\n          var right = frames[keyFrameIndex + 1];\n\n          for (key in left.props) {\n            if (hasProp.call(left.props, key)) {\n              var progress = (frame - left.frame) / (right.frame - left.frame); //Transform the current progress using the given easing function.\n\n              progress = left.props[key].easing(progress); //Interpolate between the two values\n\n              value = _calcInterpolation(left.props[key].value, right.props[key].value, progress);\n              value = _interpolateString(value); //Set style or attribute.\n\n              if (key.indexOf('@') === 0) {\n                element.setAttribute(key.substr(1), value);\n              } else {\n                skrollr.setStyle(element, key, value);\n              }\n            }\n          } //Are events enabled on this element?\n          //This code handles the usual cases of scrolling through different keyframes.\n          //The special cases of before first and after last keyframe are handled above.\n\n\n          if (emitEvents) {\n            //Did we pass a new keyframe?\n            if (lastFrameIndex !== keyFrameIndex) {\n              if (_direction === 'down') {\n                _emitEvent(element, left.eventType, _direction);\n              } else {\n                _emitEvent(element, right.eventType, _direction);\n              }\n\n              skrollable.lastFrameIndex = keyFrameIndex;\n            }\n          }\n\n          break;\n        }\n      }\n    }\n  };\n  /**\n   * Renders all elements.\n   */\n\n\n  var _render = function () {\n    if (_requestReflow) {\n      _requestReflow = false;\n\n      _reflow();\n    } //We may render something else than the actual scrollbar position.\n\n\n    var renderTop = _instance.getScrollTop(); //If there's an animation, which ends in current render call, call the callback after rendering.\n\n\n    var afterAnimationCallback;\n\n    var now = _now();\n\n    var progress; //Before actually rendering handle the scroll animation, if any.\n\n    if (_scrollAnimation) {\n      //It's over\n      if (now >= _scrollAnimation.endTime) {\n        renderTop = _scrollAnimation.targetTop;\n        afterAnimationCallback = _scrollAnimation.done;\n        _scrollAnimation = undefined;\n      } else {\n        //Map the current progress to the new progress using given easing function.\n        progress = _scrollAnimation.easing((now - _scrollAnimation.startTime) / _scrollAnimation.duration);\n        renderTop = _scrollAnimation.startTop + progress * _scrollAnimation.topDiff | 0;\n      }\n\n      _instance.setScrollTop(renderTop, true);\n    } //Smooth scrolling only if there's no animation running and if we're not forcing the rendering.\n    else if (!_forceRender) {\n        var smoothScrollingDiff = _smoothScrolling.targetTop - renderTop; //The user scrolled, start new smooth scrolling.\n\n        if (smoothScrollingDiff) {\n          _smoothScrolling = {\n            startTop: _lastTop,\n            topDiff: renderTop - _lastTop,\n            targetTop: renderTop,\n            startTime: _lastRenderCall,\n            endTime: _lastRenderCall + _smoothScrollingDuration\n          };\n        } //Interpolate the internal scroll position (not the actual scrollbar).\n\n\n        if (now <= _smoothScrolling.endTime) {\n          //Map the current progress to the new progress using easing function.\n          progress = easings.sqrt((now - _smoothScrolling.startTime) / _smoothScrollingDuration);\n          renderTop = _smoothScrolling.startTop + progress * _smoothScrolling.topDiff | 0;\n        }\n      } //Did the scroll position even change?\n\n\n    if (_forceRender || _lastTop !== renderTop) {\n      //Remember in which direction are we scrolling?\n      _direction = renderTop > _lastTop ? 'down' : renderTop < _lastTop ? 'up' : _direction;\n      _forceRender = false;\n      var listenerParams = {\n        curTop: renderTop,\n        lastTop: _lastTop,\n        maxTop: _maxKeyFrame,\n        direction: _direction\n      }; //Tell the listener we are about to render.\n\n      var continueRendering = _listeners.beforerender && _listeners.beforerender.call(_instance, listenerParams); //The beforerender listener function is able the cancel rendering.\n\n\n      if (continueRendering !== false) {\n        //Now actually interpolate all the styles.\n        _calcSteps(renderTop, _instance.getScrollTop()); //That's were we actually \"scroll\" on mobile.\n\n\n        if (_isMobile && _skrollrBody) {\n          //Set the transform (\"scroll it\").\n          skrollr.setStyle(_skrollrBody, 'transform', 'translate(0, ' + -_mobileOffset + 'px) ' + _translateZ);\n        } //Remember when we last rendered.\n\n\n        _lastTop = renderTop;\n\n        if (_listeners.render) {\n          _listeners.render.call(_instance, listenerParams);\n        }\n      }\n\n      if (afterAnimationCallback) {\n        afterAnimationCallback.call(_instance, false);\n      }\n    }\n\n    _lastRenderCall = now;\n  };\n  /**\n   * Parses the properties for each key frame of the given skrollable.\n   */\n\n\n  var _parseProps = function (skrollable) {\n    //Iterate over all key frames\n    var keyFrameIndex = 0;\n    var keyFramesLength = skrollable.keyFrames.length;\n\n    for (; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n      var frame = skrollable.keyFrames[keyFrameIndex];\n      var easing;\n      var value;\n      var prop;\n      var props = {};\n      var match;\n\n      while ((match = rxPropValue.exec(frame.props)) !== null) {\n        prop = match[1];\n        value = match[2];\n        easing = prop.match(rxPropEasing); //Is there an easing specified for this prop?\n\n        if (easing !== null) {\n          prop = easing[1];\n          easing = easing[2];\n        } else {\n          easing = DEFAULT_EASING;\n        } //Exclamation point at first position forces the value to be taken literal.\n\n\n        value = value.indexOf('!') ? _parseProp(value) : [value.slice(1)]; //Save the prop for this key frame with his value and easing function\n\n        props[prop] = {\n          value: value,\n          easing: easings[easing]\n        };\n      }\n\n      frame.props = props;\n    }\n  };\n  /**\n   * Parses a value extracting numeric values and generating a format string\n   * for later interpolation of the new values in old string.\n   *\n   * @param val The CSS value to be parsed.\n   * @return Something like [\"rgba(?%,?%, ?%,?)\", 100, 50, 0, .7]\n   * where the first element is the format string later used\n   * and all following elements are the numeric value.\n   */\n\n\n  var _parseProp = function (val) {\n    var numbers = []; //One special case, where floats don't work.\n    //We replace all occurences of rgba colors\n    //which don't use percentage notation with the percentage notation.\n\n    rxRGBAIntegerColor.lastIndex = 0;\n    val = val.replace(rxRGBAIntegerColor, function (rgba) {\n      return rgba.replace(rxNumericValue, function (n) {\n        return n / 255 * 100 + '%';\n      });\n    }); //Handle prefixing of \"gradient\" values.\n    //For now only the prefixed value will be set. Unprefixed isn't supported anyway.\n\n    if (theDashedCSSPrefix) {\n      rxGradient.lastIndex = 0;\n      val = val.replace(rxGradient, function (s) {\n        return theDashedCSSPrefix + s;\n      });\n    } //Now parse ANY number inside this string and create a format string.\n\n\n    val = val.replace(rxNumericValue, function (n) {\n      numbers.push(+n);\n      return '{?}';\n    }); //Add the formatstring as first value.\n\n    numbers.unshift(val);\n    return numbers;\n  };\n  /**\n   * Fills the key frames with missing left and right hand properties.\n   * If key frame 1 has property X and key frame 2 is missing X,\n   * but key frame 3 has X again, then we need to assign X to key frame 2 too.\n   *\n   * @param sk A skrollable.\n   */\n\n\n  var _fillProps = function (sk) {\n    //Will collect the properties key frame by key frame\n    var propList = {};\n    var keyFrameIndex;\n    var keyFramesLength; //Iterate over all key frames from left to right\n\n    keyFrameIndex = 0;\n    keyFramesLength = sk.keyFrames.length;\n\n    for (; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n      _fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);\n    } //Now do the same from right to fill the last gaps\n\n\n    propList = {}; //Iterate over all key frames from right to left\n\n    keyFrameIndex = sk.keyFrames.length - 1;\n\n    for (; keyFrameIndex >= 0; keyFrameIndex--) {\n      _fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);\n    }\n  };\n\n  var _fillPropForFrame = function (frame, propList) {\n    var key; //For each key frame iterate over all right hand properties and assign them,\n    //but only if the current key frame doesn't have the property by itself\n\n    for (key in propList) {\n      //The current frame misses this property, so assign it.\n      if (!hasProp.call(frame.props, key)) {\n        frame.props[key] = propList[key];\n      }\n    } //Iterate over all props of the current frame and collect them\n\n\n    for (key in frame.props) {\n      propList[key] = frame.props[key];\n    }\n  };\n  /**\n   * Calculates the new values for two given values array.\n   */\n\n\n  var _calcInterpolation = function (val1, val2, progress) {\n    var valueIndex;\n    var val1Length = val1.length; //They both need to have the same length\n\n    if (val1Length !== val2.length) {\n      throw 'Can\\'t interpolate between \"' + val1[0] + '\" and \"' + val2[0] + '\"';\n    } //Add the format string as first element.\n\n\n    var interpolated = [val1[0]];\n    valueIndex = 1;\n\n    for (; valueIndex < val1Length; valueIndex++) {\n      //That's the line where the two numbers are actually interpolated.\n      interpolated[valueIndex] = val1[valueIndex] + (val2[valueIndex] - val1[valueIndex]) * progress;\n    }\n\n    return interpolated;\n  };\n  /**\n   * Interpolates the numeric values into the format string.\n   */\n\n\n  var _interpolateString = function (val) {\n    var valueIndex = 1;\n    rxInterpolateString.lastIndex = 0;\n    return val[0].replace(rxInterpolateString, function () {\n      return val[valueIndex++];\n    });\n  };\n  /**\n   * Resets the class and style attribute to what it was before skrollr manipulated the element.\n   * Also remembers the values it had before reseting, in order to undo the reset.\n   */\n\n\n  var _reset = function (elements, undo) {\n    //We accept a single element or an array of elements.\n    elements = [].concat(elements);\n    var skrollable;\n    var element;\n    var elementsIndex = 0;\n    var elementsLength = elements.length;\n\n    for (; elementsIndex < elementsLength; elementsIndex++) {\n      element = elements[elementsIndex];\n      skrollable = _skrollables[element[SKROLLABLE_ID_DOM_PROPERTY]]; //Couldn't find the skrollable for this DOM element.\n\n      if (!skrollable) {\n        continue;\n      }\n\n      if (undo) {\n        //Reset class and style to the \"dirty\" (set by skrollr) values.\n        element.style.cssText = skrollable.dirtyStyleAttr;\n\n        _updateClass(element, skrollable.dirtyClassAttr);\n      } else {\n        //Remember the \"dirty\" (set by skrollr) class and style.\n        skrollable.dirtyStyleAttr = element.style.cssText;\n        skrollable.dirtyClassAttr = _getClass(element); //Reset class and style to what it originally was.\n\n        element.style.cssText = skrollable.styleAttr;\n\n        _updateClass(element, skrollable.classAttr);\n      }\n    }\n  };\n  /**\n   * Detects support for 3d transforms by applying it to the skrollr-body.\n   */\n\n\n  var _detect3DTransforms = function () {\n    _translateZ = 'translateZ(0)';\n    skrollr.setStyle(_skrollrBody, 'transform', _translateZ);\n    var computedStyle = getStyle(_skrollrBody);\n    var computedTransform = computedStyle.getPropertyValue('transform');\n    var computedTransformWithPrefix = computedStyle.getPropertyValue(theDashedCSSPrefix + 'transform');\n    var has3D = computedTransform && computedTransform !== 'none' || computedTransformWithPrefix && computedTransformWithPrefix !== 'none';\n\n    if (!has3D) {\n      _translateZ = '';\n    }\n  };\n  /**\n   * Set the CSS property on the given element. Sets prefixed properties as well.\n   */\n\n\n  skrollr.setStyle = function (el, prop, val) {\n    var style = el.style; //Camel case.\n\n    prop = prop.replace(rxCamelCase, rxCamelCaseFn).replace('-', ''); //Make sure z-index gets a <integer>.\n    //This is the only <integer> case we need to handle.\n\n    if (prop === 'zIndex') {\n      if (isNaN(val)) {\n        //If it's not a number, don't touch it.\n        //It could for example be \"auto\" (#351).\n        style[prop] = val;\n      } else {\n        //Floor the number.\n        style[prop] = '' + (val | 0);\n      }\n    } //#64: \"float\" can't be set across browsers. Needs to use \"cssFloat\" for all except IE.\n    else if (prop === 'float') {\n        style.styleFloat = style.cssFloat = val;\n      } else {\n        //Need try-catch for old IE.\n        try {\n          //Set prefixed property if there's a prefix.\n          if (theCSSPrefix) {\n            style[theCSSPrefix + prop.slice(0, 1).toUpperCase() + prop.slice(1)] = val;\n          } //Set unprefixed.\n\n\n          style[prop] = val;\n        } catch (ignore) {}\n      }\n  };\n  /**\n   * Cross browser event handling.\n   */\n\n\n  var _addEvent = skrollr.addEvent = function (element, names, callback) {\n    var intermediate = function (e) {\n      //Normalize IE event stuff.\n      e = e || window.event;\n\n      if (!e.target) {\n        e.target = e.srcElement;\n      }\n\n      if (!e.preventDefault) {\n        e.preventDefault = function () {\n          e.returnValue = false;\n          e.defaultPrevented = true;\n        };\n      }\n\n      return callback.call(this, e);\n    };\n\n    names = names.split(' ');\n    var name;\n    var nameCounter = 0;\n    var namesLength = names.length;\n\n    for (; nameCounter < namesLength; nameCounter++) {\n      name = names[nameCounter];\n\n      if (element.addEventListener) {\n        element.addEventListener(name, callback, false);\n      } else {\n        element.attachEvent('on' + name, intermediate);\n      } //Remember the events to be able to flush them later.\n\n\n      _registeredEvents.push({\n        element: element,\n        name: name,\n        listener: callback\n      });\n    }\n  };\n\n  var _removeEvent = skrollr.removeEvent = function (element, names, callback) {\n    names = names.split(' ');\n    var nameCounter = 0;\n    var namesLength = names.length;\n\n    for (; nameCounter < namesLength; nameCounter++) {\n      if (element.removeEventListener) {\n        element.removeEventListener(names[nameCounter], callback, false);\n      } else {\n        element.detachEvent('on' + names[nameCounter], callback);\n      }\n    }\n  };\n\n  var _removeAllEvents = function () {\n    var eventData;\n    var eventCounter = 0;\n    var eventsLength = _registeredEvents.length;\n\n    for (; eventCounter < eventsLength; eventCounter++) {\n      eventData = _registeredEvents[eventCounter];\n\n      _removeEvent(eventData.element, eventData.name, eventData.listener);\n    }\n\n    _registeredEvents = [];\n  };\n\n  var _emitEvent = function (element, name, direction) {\n    if (_listeners.keyframe) {\n      _listeners.keyframe.call(_instance, element, name, direction);\n    }\n  };\n\n  var _reflow = function () {\n    var pos = _instance.getScrollTop(); //Will be recalculated by _updateDependentKeyFrames.\n\n\n    _maxKeyFrame = 0;\n\n    if (_forceHeight && !_isMobile) {\n      //un-\"force\" the height to not mess with the calculations in _updateDependentKeyFrames (#216).\n      body.style.height = '';\n    }\n\n    _updateDependentKeyFrames();\n\n    if (_forceHeight && !_isMobile) {\n      //\"force\" the height.\n      body.style.height = _maxKeyFrame + documentElement.clientHeight + 'px';\n    } //The scroll offset may now be larger than needed (on desktop the browser/os prevents scrolling farther than the bottom).\n\n\n    if (_isMobile) {\n      _instance.setScrollTop(Math.min(_instance.getScrollTop(), _maxKeyFrame));\n    } else {\n      //Remember and reset the scroll pos (#217).\n      _instance.setScrollTop(pos, true);\n    }\n\n    _forceRender = true;\n  };\n  /*\n   * Returns a copy of the constants object where all functions and strings have been evaluated.\n   */\n\n\n  var _processConstants = function () {\n    var viewportHeight = documentElement.clientHeight;\n    var copy = {};\n    var prop;\n    var value;\n\n    for (prop in _constants) {\n      value = _constants[prop];\n\n      if (typeof value === 'function') {\n        value = value.call(_instance);\n      } //Percentage offset.\n      else if (/p$/.test(value)) {\n          value = value.slice(0, -1) / 100 * viewportHeight;\n        }\n\n      copy[prop] = value;\n    }\n\n    return copy;\n  };\n  /*\n   * Returns the height of the document.\n   */\n\n\n  var _getDocumentHeight = function () {\n    var skrollrBodyHeight = 0;\n    var bodyHeight;\n\n    if (_skrollrBody) {\n      skrollrBodyHeight = Math.max(_skrollrBody.offsetHeight, _skrollrBody.scrollHeight);\n    }\n\n    bodyHeight = Math.max(skrollrBodyHeight, body.scrollHeight, body.offsetHeight, documentElement.scrollHeight, documentElement.offsetHeight, documentElement.clientHeight);\n    return bodyHeight - documentElement.clientHeight;\n  };\n  /**\n   * Returns a string of space separated classnames for the current element.\n   * Works with SVG as well.\n   */\n\n\n  var _getClass = function (element) {\n    var prop = 'className'; //SVG support by using className.baseVal instead of just className.\n\n    if (window.SVGElement && element instanceof window.SVGElement) {\n      element = element[prop];\n      prop = 'baseVal';\n    }\n\n    return element[prop];\n  };\n  /**\n   * Adds and removes a CSS classes.\n   * Works with SVG as well.\n   * add and remove are arrays of strings,\n   * or if remove is ommited add is a string and overwrites all classes.\n   */\n\n\n  var _updateClass = function (element, add, remove) {\n    var prop = 'className'; //SVG support by using className.baseVal instead of just className.\n\n    if (window.SVGElement && element instanceof window.SVGElement) {\n      element = element[prop];\n      prop = 'baseVal';\n    } //When remove is ommited, we want to overwrite/set the classes.\n\n\n    if (remove === undefined) {\n      element[prop] = add;\n      return;\n    } //Cache current classes. We will work on a string before passing back to DOM.\n\n\n    var val = element[prop]; //All classes to be removed.\n\n    var classRemoveIndex = 0;\n    var removeLength = remove.length;\n\n    for (; classRemoveIndex < removeLength; classRemoveIndex++) {\n      val = _untrim(val).replace(_untrim(remove[classRemoveIndex]), ' ');\n    }\n\n    val = _trim(val); //All classes to be added.\n\n    var classAddIndex = 0;\n    var addLength = add.length;\n\n    for (; classAddIndex < addLength; classAddIndex++) {\n      //Only add if el not already has class.\n      if (_untrim(val).indexOf(_untrim(add[classAddIndex])) === -1) {\n        val += ' ' + add[classAddIndex];\n      }\n    }\n\n    element[prop] = _trim(val);\n  };\n\n  var _trim = function (a) {\n    return a.replace(rxTrim, '');\n  };\n  /**\n   * Adds a space before and after the string.\n   */\n\n\n  var _untrim = function (a) {\n    return ' ' + a + ' ';\n  };\n\n  var _now = Date.now || function () {\n    return +new Date();\n  };\n\n  var _keyFrameComparator = function (a, b) {\n    return a.frame - b.frame;\n  };\n  /*\n   * Private variables.\n   */\n  //Singleton\n\n\n  var _instance;\n  /*\n  \tA list of all elements which should be animated associated with their the metadata.\n  \tExmaple skrollable with two key frames animating from 100px width to 20px:\n  \t\tskrollable = {\n  \t\telement: <the DOM element>,\n  \t\tstyleAttr: <style attribute of the element before skrollr>,\n  \t\tclassAttr: <class attribute of the element before skrollr>,\n  \t\tkeyFrames: [\n  \t\t\t{\n  \t\t\t\tframe: 100,\n  \t\t\t\tprops: {\n  \t\t\t\t\twidth: {\n  \t\t\t\t\t\tvalue: ['{?}px', 100],\n  \t\t\t\t\t\teasing: <reference to easing function>\n  \t\t\t\t\t}\n  \t\t\t\t},\n  \t\t\t\tmode: \"absolute\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tframe: 200,\n  \t\t\t\tprops: {\n  \t\t\t\t\twidth: {\n  \t\t\t\t\t\tvalue: ['{?}px', 20],\n  \t\t\t\t\t\teasing: <reference to easing function>\n  \t\t\t\t\t}\n  \t\t\t\t},\n  \t\t\t\tmode: \"absolute\"\n  \t\t\t}\n  \t\t]\n  \t};\n  */\n\n\n  var _skrollables;\n\n  var _skrollrBody;\n\n  var _listeners;\n\n  var _forceHeight;\n\n  var _maxKeyFrame = 0;\n  var _scale = 1;\n\n  var _constants;\n\n  var _mobileDeceleration; //Current direction (up/down).\n\n\n  var _direction = 'down'; //The last top offset value. Needed to determine direction.\n\n  var _lastTop = -1; //The last time we called the render method (doesn't mean we rendered!).\n\n\n  var _lastRenderCall = _now(); //For detecting if it actually resized (#271).\n\n\n  var _lastViewportWidth = 0;\n  var _lastViewportHeight = 0;\n  var _requestReflow = false; //Will contain data about a running scrollbar animation, if any.\n\n  var _scrollAnimation;\n\n  var _smoothScrollingEnabled;\n\n  var _smoothScrollingDuration; //Will contain settins for smooth scrolling if enabled.\n\n\n  var _smoothScrolling; //Can be set by any operation/event to force rendering even if the scrollbar didn't move.\n\n\n  var _forceRender; //Each skrollable gets an unique ID incremented for each skrollable.\n  //The ID is the index in the _skrollables array.\n\n\n  var _skrollableIdCounter = 0;\n\n  var _edgeStrategy; //Mobile specific vars. Will be stripped by UglifyJS when not in use.\n\n\n  var _isMobile = false; //The virtual scroll offset when using mobile scrolling.\n\n  var _mobileOffset = 0; //If the browser supports 3d transforms, this will be filled with 'translateZ(0)' (empty string otherwise).\n\n  var _translateZ; //Will contain data about registered events by skrollr.\n\n\n  var _registeredEvents = []; //Animation frame id returned by RequestAnimationFrame (or timeout when RAF is not supported).\n\n  var _animFrame; //Expose skrollr as either a global variable or a require.js module.\n  // if(typeof define === 'function' && define.amd) {\n  // \tdefine([], function () {\n  // \t\treturn skrollr;\n  // \t});\n  // } else if (typeof module !== 'undefined' && module.exports) {\n  // \tmodule.exports = skrollr;\n  // } else {\n  // \twindow.skrollr = skrollr;\n  // }\n\n})(window, document);","map":{"version":3,"sources":["/home/kido3/Desktop/Kido/kido-village-new/src/skrollr.js"],"names":["window","document","undefined","skrollr","get","_instance","init","options","Skrollr","VERSION","hasProp","Object","prototype","hasOwnProperty","Math","getStyle","getComputedStyle","documentElement","body","EVENT_TOUCHSTART","EVENT_TOUCHMOVE","EVENT_TOUCHCANCEL","EVENT_TOUCHEND","SKROLLABLE_CLASS","SKROLLABLE_BEFORE_CLASS","SKROLLABLE_BETWEEN_CLASS","SKROLLABLE_AFTER_CLASS","SKROLLR_CLASS","NO_SKROLLR_CLASS","SKROLLR_DESKTOP_CLASS","SKROLLR_MOBILE_CLASS","DEFAULT_EASING","DEFAULT_DURATION","DEFAULT_MOBILE_DECELERATION","DEFAULT_SKROLLRBODY","DEFAULT_SMOOTH_SCROLLING_DURATION","ANCHOR_START","ANCHOR_END","ANCHOR_CENTER","ANCHOR_BOTTOM","SKROLLABLE_ID_DOM_PROPERTY","rxTouchIgnoreTags","rxTrim","rxKeyframeAttribute","rxPropValue","rxPropEasing","rxCamelCase","rxCamelCaseFn","str","letter","toUpperCase","rxNumericValue","rxInterpolateString","rxRGBAIntegerColor","rxGradient","theCSSPrefix","theDashedCSSPrefix","detectCSSPrefix","rxPrefixes","style","k","match","slice","toLowerCase","polyfillRAF","requestAnimFrame","requestAnimationFrame","lastTime","_now","_isMobile","callback","deltaTime","delay","max","setTimeout","polyfillCAF","cancelAnimFrame","cancelAnimationFrame","timeout","clearTimeout","easings","begin","end","linear","p","quadratic","cubic","swing","cos","PI","sqrt","outCubic","pow","bounce","a","abs","_constants","constants","easing","e","_edgeStrategy","edgeStrategy","_listeners","beforerender","render","keyframe","_forceHeight","forceHeight","_scale","scale","_mobileDeceleration","mobileDeceleration","_smoothScrollingEnabled","smoothScrolling","_smoothScrollingDuration","smoothScrollingDuration","_smoothScrolling","targetTop","getScrollTop","mobileCheck","test","navigator","userAgent","vendor","opera","_skrollrBody","getElementById","skrollrBody","_detect3DTransforms","_initMobile","_updateClass","refresh","_addEvent","width","clientWidth","height","clientHeight","_lastViewportHeight","_lastViewportWidth","_requestReflow","animloop","_render","_animFrame","elements","elementIndex","elementsLength","ignoreID","_skrollables","_skrollableIdCounter","getElementsByTagName","length","el","anchorTarget","keyFrames","smoothScrollThis","emitEvents","attributes","attributeIndex","attributesLength","attr","name","querySelector","value","kf","props","element","eventType","replace","push","constant","substr","offset","isPercentage","anchor1","anchor2","mode","isEnd","anchors","styleAttr","classAttr","id","cssText","_getClass","lastFrameIndex","_reflow","sk","_parseProps","_fillProps","relativeToAbsolute","viewportAnchor","elementAnchor","viewportHeight","box","getBoundingClientRect","absolute","top","boxHeight","bottom","animateTo","now","scrollTop","duration","_scrollAnimation","startTop","topDiff","startTime","endTime","done","call","stopAnimateTo","isAnimatingTo","isMobile","setScrollTop","force","_forceRender","_mobileOffset","min","_maxKeyFrame","scrollTo","pageYOffset","getMaxScrollTop","on","fn","off","destroy","_removeAllEvents","skrollableIndex","skrollablesLength","_reset","overflow","setStyle","_direction","_lastTop","_translateZ","initialElement","initialTouchY","initialTouchX","currentElement","currentTouchY","currentTouchX","lastTouchY","deltaY","initialTouchTime","currentTouchTime","lastTouchTime","join","touch","changedTouches","target","nodeType","parentNode","clientY","clientX","timeStamp","tagName","preventDefault","type","blur","activeElement","distanceY","distanceX","distance2","focus","clickEvent","createEvent","initMouseEvent","view","screenX","screenY","ctrlKey","altKey","shiftKey","metaKey","dispatchEvent","speed","targetOffset","targetRatio","_updateDependentKeyFrames","processedConstants","_processConstants","skrollable","keyFrameIndex","keyFramesLength","constantValue","frame","_getDocumentHeight","sort","_keyFrameComparator","_calcSteps","fakeFrame","actualFrame","frames","framesLength","firstFrame","lastFrame","beforeFirst","afterLast","firstOrLastFrame","key","edge","_emitEvent","_interpolateString","indexOf","setAttribute","left","right","progress","_calcInterpolation","renderTop","afterAnimationCallback","smoothScrollingDiff","_lastRenderCall","listenerParams","curTop","lastTop","maxTop","direction","continueRendering","prop","exec","_parseProp","val","numbers","lastIndex","rgba","n","s","unshift","propList","_fillPropForFrame","val1","val2","valueIndex","val1Length","interpolated","undo","concat","elementsIndex","dirtyStyleAttr","dirtyClassAttr","computedStyle","computedTransform","getPropertyValue","computedTransformWithPrefix","has3D","isNaN","styleFloat","cssFloat","ignore","addEvent","names","intermediate","event","srcElement","returnValue","defaultPrevented","split","nameCounter","namesLength","addEventListener","attachEvent","_registeredEvents","listener","_removeEvent","removeEvent","removeEventListener","detachEvent","eventData","eventCounter","eventsLength","pos","copy","skrollrBodyHeight","bodyHeight","offsetHeight","scrollHeight","SVGElement","add","remove","classRemoveIndex","removeLength","_untrim","_trim","classAddIndex","addLength","Date","b"],"mappings":"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","sourcesContent":["/*!\n * skrollr core\n *\n * Alexander Prinzhorn - https://github.com/Prinzhorn/skrollr\n *\n * Free to use under terms of MIT license\n */\n(function(window, document, undefined) {\n\t'use strict';\n\n\t/*\n\t * Global api.\n\t */\n\tvar skrollr = {\n\t\tget: function() {\n\t\t\treturn _instance;\n\t\t},\n\t\t//Main entry point.\n\t\tinit: function(options) {\n\t\t\treturn _instance || new Skrollr(options);\n\t\t},\n\t\tVERSION: '0.6.30'\n\t};\n\n\t//Minify optimization.\n\tvar hasProp = Object.prototype.hasOwnProperty;\n\tvar Math = window.Math;\n\tvar getStyle = window.getComputedStyle;\n\n\t//They will be filled when skrollr gets initialized.\n\tvar documentElement;\n\tvar body;\n\n\tvar EVENT_TOUCHSTART = 'touchstart';\n\tvar EVENT_TOUCHMOVE = 'touchmove';\n\tvar EVENT_TOUCHCANCEL = 'touchcancel';\n\tvar EVENT_TOUCHEND = 'touchend';\n\n\tvar SKROLLABLE_CLASS = 'skrollable';\n\tvar SKROLLABLE_BEFORE_CLASS = SKROLLABLE_CLASS + '-before';\n\tvar SKROLLABLE_BETWEEN_CLASS = SKROLLABLE_CLASS + '-between';\n\tvar SKROLLABLE_AFTER_CLASS = SKROLLABLE_CLASS + '-after';\n\n\tvar SKROLLR_CLASS = 'skrollr';\n\tvar NO_SKROLLR_CLASS = 'no-' + SKROLLR_CLASS;\n\tvar SKROLLR_DESKTOP_CLASS = SKROLLR_CLASS + '-desktop';\n\tvar SKROLLR_MOBILE_CLASS = SKROLLR_CLASS + '-mobile';\n\n\tvar DEFAULT_EASING = 'linear';\n\tvar DEFAULT_DURATION = 1000;//ms\n\tvar DEFAULT_MOBILE_DECELERATION = 0.004;//pixel/msÂ²\n\n\tvar DEFAULT_SKROLLRBODY = 'skrollr-body';\n\n\tvar DEFAULT_SMOOTH_SCROLLING_DURATION = 200;//ms\n\n\tvar ANCHOR_START = 'start';\n\tvar ANCHOR_END = 'end';\n\tvar ANCHOR_CENTER = 'center';\n\tvar ANCHOR_BOTTOM = 'bottom';\n\n\t//The property which will be added to the DOM element to hold the ID of the skrollable.\n\tvar SKROLLABLE_ID_DOM_PROPERTY = '___skrollable_id';\n\n\tvar rxTouchIgnoreTags = /^(?:input|textarea|button|select)$/i;\n\n\tvar rxTrim = /^\\s+|\\s+$/g;\n\n\t//Find all data-attributes. data-[_constant]-[offset]-[anchor]-[anchor].\n\tvar rxKeyframeAttribute = /^data(?:-(_\\w+))?(?:-?(-?\\d*\\.?\\d+p?))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/;\n\n\tvar rxPropValue = /\\s*(@?[\\w\\-\\[\\]]+)\\s*:\\s*(.+?)\\s*(?:;|$)/gi;\n\n\t//Easing function names follow the property in square brackets.\n\tvar rxPropEasing = /^(@?[a-z\\-]+)\\[(\\w+)\\]$/;\n\n\tvar rxCamelCase = /-([a-z0-9_])/g;\n\tvar rxCamelCaseFn = function(str, letter) {\n\t\treturn letter.toUpperCase();\n\t};\n\n\t//Numeric values with optional sign.\n\tvar rxNumericValue = /[\\-+]?[\\d]*\\.?[\\d]+/g;\n\n\t//Used to replace occurences of {?} with a number.\n\tvar rxInterpolateString = /\\{\\?\\}/g;\n\n\t//Finds rgb(a) colors, which don't use the percentage notation.\n\tvar rxRGBAIntegerColor = /rgba?\\(\\s*-?\\d+\\s*,\\s*-?\\d+\\s*,\\s*-?\\d+/g;\n\n\t//Finds all gradients.\n\tvar rxGradient = /[a-z\\-]+-gradient/g;\n\n\t//Vendor prefix. Will be set once skrollr gets initialized.\n\tvar theCSSPrefix = '';\n\tvar theDashedCSSPrefix = '';\n\n\t//Will be called once (when skrollr gets initialized).\n\tvar detectCSSPrefix = function() {\n\t\t//Only relevant prefixes. May be extended.\n\t\t//Could be dangerous if there will ever be a CSS property which actually starts with \"ms\". Don't hope so.\n\t\tvar rxPrefixes = /^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/;\n\n\t\t//Detect prefix for current browser by finding the first property using a prefix.\n\t\tif(!getStyle) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar style = getStyle(body, null);\n\n\t\tfor(var k in style) {\n\t\t\t//We check the key and if the key is a number, we check the value as well, because safari's getComputedStyle returns some weird array-like thingy.\n\t\t\ttheCSSPrefix = (k.match(rxPrefixes) || (+k == k && style[k].match(rxPrefixes)));\n\n\t\t\tif(theCSSPrefix) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//Did we even detect a prefix?\n\t\tif(!theCSSPrefix) {\n\t\t\ttheCSSPrefix = theDashedCSSPrefix = '';\n\n\t\t\treturn;\n\t\t}\n\n\t\ttheCSSPrefix = theCSSPrefix[0];\n\n\t\t//We could have detected either a dashed prefix or this camelCaseish-inconsistent stuff.\n\t\tif(theCSSPrefix.slice(0,1) === '-') {\n\t\t\ttheDashedCSSPrefix = theCSSPrefix;\n\n\t\t\t//There's no logic behind these. Need a look up.\n\t\t\ttheCSSPrefix = ({\n\t\t\t\t'-webkit-': 'webkit',\n\t\t\t\t'-moz-': 'Moz',\n\t\t\t\t'-ms-': 'ms',\n\t\t\t\t'-o-': 'O'\n\t\t\t})[theCSSPrefix];\n\t\t} else {\n\t\t\ttheDashedCSSPrefix = '-' + theCSSPrefix.toLowerCase() + '-';\n\t\t}\n\t};\n\n\tvar polyfillRAF = function() {\n\t\tvar requestAnimFrame = window.requestAnimationFrame || window[theCSSPrefix.toLowerCase() + 'RequestAnimationFrame'];\n\n\t\tvar lastTime = _now();\n\n\t\tif(_isMobile || !requestAnimFrame) {\n\t\t\trequestAnimFrame = function(callback) {\n\t\t\t\t//How long did it take to render?\n\t\t\t\tvar deltaTime = _now() - lastTime;\n\t\t\t\tvar delay = Math.max(0, 1000 / 60 - deltaTime);\n\n\t\t\t\treturn window.setTimeout(function() {\n\t\t\t\t\tlastTime = _now();\n\t\t\t\t\tcallback();\n\t\t\t\t}, delay);\n\t\t\t};\n\t\t}\n\n\t\treturn requestAnimFrame;\n\t};\n\n\tvar polyfillCAF = function() {\n\t\tvar cancelAnimFrame = window.cancelAnimationFrame || window[theCSSPrefix.toLowerCase() + 'CancelAnimationFrame'];\n\n\t\tif(_isMobile || !cancelAnimFrame) {\n\t\t\tcancelAnimFrame = function(timeout) {\n\t\t\t\treturn window.clearTimeout(timeout);\n\t\t\t};\n\t\t}\n\n\t\treturn cancelAnimFrame;\n\t};\n\n\t//Built-in easing functions.\n\tvar easings = {\n\t\tbegin: function() {\n\t\t\treturn 0;\n\t\t},\n\t\tend: function() {\n\t\t\treturn 1;\n\t\t},\n\t\tlinear: function(p) {\n\t\t\treturn p;\n\t\t},\n\t\tquadratic: function(p) {\n\t\t\treturn p * p;\n\t\t},\n\t\tcubic: function(p) {\n\t\t\treturn p * p * p;\n\t\t},\n\t\tswing: function(p) {\n\t\t\treturn (-Math.cos(p * Math.PI) / 2) + 0.5;\n\t\t},\n\t\tsqrt: function(p) {\n\t\t\treturn Math.sqrt(p);\n\t\t},\n\t\toutCubic: function(p) {\n\t\t\treturn (Math.pow((p - 1), 3) + 1);\n\t\t},\n\t\t//see https://www.desmos.com/calculator/tbr20s8vd2 for how I did this\n\t\tbounce: function(p) {\n\t\t\tvar a;\n\n\t\t\tif(p <= 0.5083) {\n\t\t\t\ta = 3;\n\t\t\t} else if(p <= 0.8489) {\n\t\t\t\ta = 9;\n\t\t\t} else if(p <= 0.96208) {\n\t\t\t\ta = 27;\n\t\t\t} else if(p <= 0.99981) {\n\t\t\t\ta = 91;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 1 - Math.abs(3 * Math.cos(p * a * 1.028) / a);\n\t\t}\n\t};\n\n\t/**\n\t * Constructor.\n\t */\n\tfunction Skrollr(options) {\n\t\tdocumentElement = document.documentElement;\n\t\tbody = document.body;\n\n\t\tdetectCSSPrefix();\n\n\t\t_instance = this;\n\n\t\toptions = options || {};\n\n\t\t_constants = options.constants || {};\n\n\t\t//We allow defining custom easings or overwrite existing.\n\t\tif(options.easing) {\n\t\t\tfor(var e in options.easing) {\n\t\t\t\teasings[e] = options.easing[e];\n\t\t\t}\n\t\t}\n\n\t\t_edgeStrategy = options.edgeStrategy || 'set';\n\n\t\t_listeners = {\n\t\t\t//Function to be called right before rendering.\n\t\t\tbeforerender: options.beforerender,\n\n\t\t\t//Function to be called right after finishing rendering.\n\t\t\trender: options.render,\n\n\t\t\t//Function to be called whenever an element with the `data-emit-events` attribute passes a keyframe.\n\t\t\tkeyframe: options.keyframe\n\t\t};\n\n\t\t//forceHeight is true by default\n\t\t_forceHeight = options.forceHeight !== false;\n\n\t\tif(_forceHeight) {\n\t\t\t_scale = options.scale || 1;\n\t\t}\n\n\t\t_mobileDeceleration = options.mobileDeceleration || DEFAULT_MOBILE_DECELERATION;\n\n\t\t_smoothScrollingEnabled = options.smoothScrolling !== false;\n\t\t_smoothScrollingDuration = options.smoothScrollingDuration || DEFAULT_SMOOTH_SCROLLING_DURATION;\n\n\t\t//Dummy object. Will be overwritten in the _render method when smooth scrolling is calculated.\n\t\t_smoothScrolling = {\n\t\t\ttargetTop: _instance.getScrollTop()\n\t\t};\n\n\t\t//A custom check function may be passed.\n\t\t_isMobile = ((options.mobileCheck || function() {\n\t\t\treturn (/Android|iPhone|iPad|iPod|BlackBerry/i).test(navigator.userAgent || navigator.vendor || window.opera);\n\t\t})());\n\n\t\tif(_isMobile) {\n\t\t\t_skrollrBody = document.getElementById(options.skrollrBody || DEFAULT_SKROLLRBODY);\n\n\t\t\t//Detect 3d transform if there's a skrollr-body (only needed for #skrollr-body).\n\t\t\tif(_skrollrBody) {\n\t\t\t\t_detect3DTransforms();\n\t\t\t}\n\n\t\t\t_initMobile();\n\t\t\t_updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_MOBILE_CLASS], [NO_SKROLLR_CLASS]);\n\t\t} else {\n\t\t\t_updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS], [NO_SKROLLR_CLASS]);\n\t\t}\n\n\t\t//Triggers parsing of elements and a first reflow.\n\t\t_instance.refresh();\n\n\t\t_addEvent(window, 'resize orientationchange', function() {\n\t\t\tvar width = documentElement.clientWidth;\n\t\t\tvar height = documentElement.clientHeight;\n\n\t\t\t//Only reflow if the size actually changed (#271).\n\t\t\tif(height !== _lastViewportHeight || width !== _lastViewportWidth) {\n\t\t\t\t_lastViewportHeight = height;\n\t\t\t\t_lastViewportWidth = width;\n\n\t\t\t\t_requestReflow = true;\n\t\t\t}\n\t\t});\n\n\t\tvar requestAnimFrame = polyfillRAF();\n\n\t\t//Let's go.\n\t\t(function animloop(){\n\t\t\t_render();\n\t\t\t_animFrame = requestAnimFrame(animloop);\n\t\t}());\n\n\t\treturn _instance;\n\t}\n\n\t/**\n\t * (Re)parses some or all elements.\n\t */\n\tSkrollr.prototype.refresh = function(elements) {\n\t\tvar elementIndex;\n\t\tvar elementsLength;\n\t\tvar ignoreID = false;\n\n\t\t//Completely reparse anything without argument.\n\t\tif(elements === undefined) {\n\t\t\t//Ignore that some elements may already have a skrollable ID.\n\t\t\tignoreID = true;\n\n\t\t\t_skrollables = [];\n\t\t\t_skrollableIdCounter = 0;\n\n\t\t\telements = document.getElementsByTagName('*');\n\t\t} else if(elements.length === undefined) {\n\t\t\t//We also accept a single element as parameter.\n\t\t\telements = [elements];\n\t\t}\n\n\t\telementIndex = 0;\n\t\telementsLength = elements.length;\n\n\t\tfor(; elementIndex < elementsLength; elementIndex++) {\n\t\t\tvar el = elements[elementIndex];\n\t\t\tvar anchorTarget = el;\n\t\t\tvar keyFrames = [];\n\n\t\t\t//If this particular element should be smooth scrolled.\n\t\t\tvar smoothScrollThis = _smoothScrollingEnabled;\n\n\t\t\t//The edge strategy for this particular element.\n\t\t\tvar edgeStrategy = _edgeStrategy;\n\n\t\t\t//If this particular element should emit keyframe events.\n\t\t\tvar emitEvents = false;\n\n\t\t\t//If we're reseting the counter, remove any old element ids that may be hanging around.\n\t\t\tif(ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {\n\t\t\t\tdelete el[SKROLLABLE_ID_DOM_PROPERTY];\n\t\t\t}\n\n\t\t\tif(!el.attributes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//Iterate over all attributes and search for key frame attributes.\n\t\t\tvar attributeIndex = 0;\n\t\t\tvar attributesLength = el.attributes.length;\n\n\t\t\tfor (; attributeIndex < attributesLength; attributeIndex++) {\n\t\t\t\tvar attr = el.attributes[attributeIndex];\n\n\t\t\t\tif(attr.name === 'data-anchor-target') {\n\t\t\t\t\tanchorTarget = document.querySelector(attr.value);\n\n\t\t\t\t\tif(anchorTarget === null) {\n\t\t\t\t\t\tthrow 'Unable to find anchor target \"' + attr.value + '\"';\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Global smooth scrolling can be overridden by the element attribute.\n\t\t\t\tif(attr.name === 'data-smooth-scrolling') {\n\t\t\t\t\tsmoothScrollThis = attr.value !== 'off';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Global edge strategy can be overridden by the element attribute.\n\t\t\t\tif(attr.name === 'data-edge-strategy') {\n\t\t\t\t\tedgeStrategy = attr.value;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Is this element tagged with the `data-emit-events` attribute?\n\t\t\t\tif(attr.name === 'data-emit-events') {\n\t\t\t\t\temitEvents = true;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar match = attr.name.match(rxKeyframeAttribute);\n\n\t\t\t\tif(match === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar kf = {\n\t\t\t\t\tprops: attr.value,\n\t\t\t\t\t//Point back to the element as well.\n\t\t\t\t\telement: el,\n\t\t\t\t\t//The name of the event which this keyframe will fire, if emitEvents is\n\t\t\t\t\teventType: attr.name.replace(rxCamelCase, rxCamelCaseFn)\n\t\t\t\t};\n\n\t\t\t\tkeyFrames.push(kf);\n\n\t\t\t\tvar constant = match[1];\n\n\t\t\t\tif(constant) {\n\t\t\t\t\t//Strip the underscore prefix.\n\t\t\t\t\tkf.constant = constant.substr(1);\n\t\t\t\t}\n\n\t\t\t\t//Get the key frame offset.\n\t\t\t\tvar offset = match[2];\n\n\t\t\t\t//Is it a percentage offset?\n\t\t\t\tif(/p$/.test(offset)) {\n\t\t\t\t\tkf.isPercentage = true;\n\t\t\t\t\tkf.offset = (offset.slice(0, -1) | 0) / 100;\n\t\t\t\t} else {\n\t\t\t\t\tkf.offset = (offset | 0);\n\t\t\t\t}\n\n\t\t\t\tvar anchor1 = match[3];\n\n\t\t\t\t//If second anchor is not set, the first will be taken for both.\n\t\t\t\tvar anchor2 = match[4] || anchor1;\n\n\t\t\t\t//\"absolute\" (or \"classic\") mode, where numbers mean absolute scroll offset.\n\t\t\t\tif(!anchor1 || anchor1 === ANCHOR_START || anchor1 === ANCHOR_END) {\n\t\t\t\t\tkf.mode = 'absolute';\n\n\t\t\t\t\t//data-end needs to be calculated after all key frames are known.\n\t\t\t\t\tif(anchor1 === ANCHOR_END) {\n\t\t\t\t\t\tkf.isEnd = true;\n\t\t\t\t\t} else if(!kf.isPercentage) {\n\t\t\t\t\t\t//For data-start we can already set the key frame w/o calculations.\n\t\t\t\t\t\t//#59: \"scale\" options should only affect absolute mode.\n\t\t\t\t\t\tkf.offset = kf.offset * _scale;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\"relative\" mode, where numbers are relative to anchors.\n\t\t\t\telse {\n\t\t\t\t\tkf.mode = 'relative';\n\t\t\t\t\tkf.anchors = [anchor1, anchor2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Does this element have key frames?\n\t\t\tif(!keyFrames.length) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//Will hold the original style and class attributes before we controlled the element (see #80).\n\t\t\tvar styleAttr, classAttr;\n\n\t\t\tvar id;\n\n\t\t\tif(!ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {\n\t\t\t\t//We already have this element under control. Grab the corresponding skrollable id.\n\t\t\t\tid = el[SKROLLABLE_ID_DOM_PROPERTY];\n\t\t\t\tstyleAttr = _skrollables[id].styleAttr;\n\t\t\t\tclassAttr = _skrollables[id].classAttr;\n\t\t\t} else {\n\t\t\t\t//It's an unknown element. Asign it a new skrollable id.\n\t\t\t\tid = (el[SKROLLABLE_ID_DOM_PROPERTY] = _skrollableIdCounter++);\n\t\t\t\tstyleAttr = el.style.cssText;\n\t\t\t\tclassAttr = _getClass(el);\n\t\t\t}\n\n\t\t\t_skrollables[id] = {\n\t\t\t\telement: el,\n\t\t\t\tstyleAttr: styleAttr,\n\t\t\t\tclassAttr: classAttr,\n\t\t\t\tanchorTarget: anchorTarget,\n\t\t\t\tkeyFrames: keyFrames,\n\t\t\t\tsmoothScrolling: smoothScrollThis,\n\t\t\t\tedgeStrategy: edgeStrategy,\n\t\t\t\temitEvents: emitEvents,\n\t\t\t\tlastFrameIndex: -1\n\t\t\t};\n\n\t\t\t_updateClass(el, [SKROLLABLE_CLASS], []);\n\t\t}\n\n\t\t//Reflow for the first time.\n\t\t_reflow();\n\n\t\t//Now that we got all key frame numbers right, actually parse the properties.\n\t\telementIndex = 0;\n\t\telementsLength = elements.length;\n\n\t\tfor(; elementIndex < elementsLength; elementIndex++) {\n\t\t\tvar sk = _skrollables[elements[elementIndex][SKROLLABLE_ID_DOM_PROPERTY]];\n\n\t\t\tif(sk === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//Parse the property string to objects\n\t\t\t_parseProps(sk);\n\n\t\t\t//Fill key frames with missing properties from left and right\n\t\t\t_fillProps(sk);\n\t\t}\n\n\t\treturn _instance;\n\t};\n\n\t/**\n\t * Transform \"relative\" mode to \"absolute\" mode.\n\t * That is, calculate anchor position and offset of element.\n\t */\n\tSkrollr.prototype.relativeToAbsolute = function(element, viewportAnchor, elementAnchor) {\n\t\tvar viewportHeight = documentElement.clientHeight;\n\t\tvar box = element.getBoundingClientRect();\n\t\tvar absolute = box.top;\n\n\t\t//#100: IE doesn't supply \"height\" with getBoundingClientRect.\n\t\tvar boxHeight = box.bottom - box.top;\n\n\t\tif(viewportAnchor === ANCHOR_BOTTOM) {\n\t\t\tabsolute -= viewportHeight;\n\t\t} else if(viewportAnchor === ANCHOR_CENTER) {\n\t\t\tabsolute -= viewportHeight / 2;\n\t\t}\n\n\t\tif(elementAnchor === ANCHOR_BOTTOM) {\n\t\t\tabsolute += boxHeight;\n\t\t} else if(elementAnchor === ANCHOR_CENTER) {\n\t\t\tabsolute += boxHeight / 2;\n\t\t}\n\n\t\t//Compensate scrolling since getBoundingClientRect is relative to viewport.\n\t\tabsolute += _instance.getScrollTop();\n\n\t\treturn (absolute + 0.5) | 0;\n\t};\n\n\t/**\n\t * Animates scroll top to new position.\n\t */\n\tSkrollr.prototype.animateTo = function(top, options) {\n\t\toptions = options || {};\n\n\t\tvar now = _now();\n\t\tvar scrollTop = _instance.getScrollTop();\n\t\tvar duration = options.duration === undefined ? DEFAULT_DURATION : options.duration;\n\n\t\t//Setting this to a new value will automatically cause the current animation to stop, if any.\n\t\t_scrollAnimation = {\n\t\t\tstartTop: scrollTop,\n\t\t\ttopDiff: top - scrollTop,\n\t\t\ttargetTop: top,\n\t\t\tduration: duration,\n\t\t\tstartTime: now,\n\t\t\tendTime: now + duration,\n\t\t\teasing: easings[options.easing || DEFAULT_EASING],\n\t\t\tdone: options.done\n\t\t};\n\n\t\t//Don't queue the animation if there's nothing to animate.\n\t\tif(!_scrollAnimation.topDiff) {\n\t\t\tif(_scrollAnimation.done) {\n\t\t\t\t_scrollAnimation.done.call(_instance, false);\n\t\t\t}\n\n\t\t\t_scrollAnimation = undefined;\n\t\t}\n\n\t\treturn _instance;\n\t};\n\n\t/**\n\t * Stops animateTo animation.\n\t */\n\tSkrollr.prototype.stopAnimateTo = function() {\n\t\tif(_scrollAnimation && _scrollAnimation.done) {\n\t\t\t_scrollAnimation.done.call(_instance, true);\n\t\t}\n\n\t\t_scrollAnimation = undefined;\n\t};\n\n\t/**\n\t * Returns if an animation caused by animateTo is currently running.\n\t */\n\tSkrollr.prototype.isAnimatingTo = function() {\n\t\treturn !!_scrollAnimation;\n\t};\n\n\tSkrollr.prototype.isMobile = function() {\n\t\treturn _isMobile;\n\t};\n\n\tSkrollr.prototype.setScrollTop = function(top, force) {\n\t\t_forceRender = (force === true);\n\n\t\tif(_isMobile) {\n\t\t\t_mobileOffset = Math.min(Math.max(top, 0), _maxKeyFrame);\n\t\t} else {\n\t\t\twindow.scrollTo(0, top);\n\t\t}\n\n\t\treturn _instance;\n\t};\n\n\tSkrollr.prototype.getScrollTop = function() {\n\t\tif(_isMobile) {\n\t\t\treturn _mobileOffset;\n\t\t} else {\n\t\t\treturn window.pageYOffset || documentElement.scrollTop || body.scrollTop || 0;\n\t\t}\n\t};\n\n\tSkrollr.prototype.getMaxScrollTop = function() {\n\t\treturn _maxKeyFrame;\n\t};\n\n\tSkrollr.prototype.on = function(name, fn) {\n\t\t_listeners[name] = fn;\n\n\t\treturn _instance;\n\t};\n\n\tSkrollr.prototype.off = function(name) {\n\t\tdelete _listeners[name];\n\n\t\treturn _instance;\n\t};\n\n\tSkrollr.prototype.destroy = function() {\n\t\tvar cancelAnimFrame = polyfillCAF();\n\t\tcancelAnimFrame(_animFrame);\n\t\t_removeAllEvents();\n\n\t\t_updateClass(documentElement, [NO_SKROLLR_CLASS], [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS, SKROLLR_MOBILE_CLASS]);\n\n\t\tvar skrollableIndex = 0;\n\t\tvar skrollablesLength = _skrollables.length;\n\n\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {\n\t\t\t_reset(_skrollables[skrollableIndex].element);\n\t\t}\n\n\t\tdocumentElement.style.overflow = body.style.overflow = '';\n\t\tdocumentElement.style.height = body.style.height = '';\n\n\t\tif(_skrollrBody) {\n\t\t\tskrollr.setStyle(_skrollrBody, 'transform', 'none');\n\t\t}\n\n\t\t_instance = undefined;\n\t\t_skrollrBody = undefined;\n\t\t_listeners = undefined;\n\t\t_forceHeight = undefined;\n\t\t_maxKeyFrame = 0;\n\t\t_scale = 1;\n\t\t_constants = undefined;\n\t\t_mobileDeceleration = undefined;\n\t\t_direction = 'down';\n\t\t_lastTop = -1;\n\t\t_lastViewportWidth = 0;\n\t\t_lastViewportHeight = 0;\n\t\t_requestReflow = false;\n\t\t_scrollAnimation = undefined;\n\t\t_smoothScrollingEnabled = undefined;\n\t\t_smoothScrollingDuration = undefined;\n\t\t_smoothScrolling = undefined;\n\t\t_forceRender = undefined;\n\t\t_skrollableIdCounter = 0;\n\t\t_edgeStrategy = undefined;\n\t\t_isMobile = false;\n\t\t_mobileOffset = 0;\n\t\t_translateZ = undefined;\n\t};\n\n\t/*\n\t\tPrivate methods.\n\t*/\n\n\tvar _initMobile = function() {\n\t\tvar initialElement;\n\t\tvar initialTouchY;\n\t\tvar initialTouchX;\n\t\tvar currentElement;\n\t\tvar currentTouchY;\n\t\tvar currentTouchX;\n\t\tvar lastTouchY;\n\t\tvar deltaY;\n\n\t\tvar initialTouchTime;\n\t\tvar currentTouchTime;\n\t\tvar lastTouchTime;\n\t\tvar deltaTime;\n\n\t\t_addEvent(documentElement, [EVENT_TOUCHSTART, EVENT_TOUCHMOVE, EVENT_TOUCHCANCEL, EVENT_TOUCHEND].join(' '), function(e) {\n\t\t\tvar touch = e.changedTouches[0];\n\n\t\t\tcurrentElement = e.target;\n\n\t\t\t//We don't want text nodes.\n\t\t\twhile(currentElement.nodeType === 3) {\n\t\t\t\tcurrentElement = currentElement.parentNode;\n\t\t\t}\n\n\t\t\tcurrentTouchY = touch.clientY;\n\t\t\tcurrentTouchX = touch.clientX;\n\t\t\tcurrentTouchTime = e.timeStamp;\n\n\t\t\tif(!rxTouchIgnoreTags.test(currentElement.tagName)) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\n\t\t\tswitch(e.type) {\n\t\t\t\tcase EVENT_TOUCHSTART:\n\t\t\t\t\t//The last element we tapped on.\n\t\t\t\t\tif(initialElement) {\n\t\t\t\t\t\tinitialElement.blur();\n\t\t\t\t\t}\n\n\t\t\t\t\t_instance.stopAnimateTo();\n\n\t\t\t\t\tinitialElement = currentElement;\n\n\t\t\t\t\tinitialTouchY = lastTouchY = currentTouchY;\n\t\t\t\t\tinitialTouchX = currentTouchX;\n\t\t\t\t\tinitialTouchTime = currentTouchTime;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EVENT_TOUCHMOVE:\n\t\t\t\t\t//Prevent default event on touchIgnore elements in case they don't have focus yet.\n\t\t\t\t\tif(rxTouchIgnoreTags.test(currentElement.tagName) && document.activeElement !== currentElement) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t}\n\n\t\t\t\t\tdeltaY = currentTouchY - lastTouchY;\n\t\t\t\t\tdeltaTime = currentTouchTime - lastTouchTime;\n\n\t\t\t\t\t_instance.setScrollTop(_mobileOffset - deltaY, true);\n\n\t\t\t\t\tlastTouchY = currentTouchY;\n\t\t\t\t\tlastTouchTime = currentTouchTime;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase EVENT_TOUCHCANCEL:\n\t\t\t\tcase EVENT_TOUCHEND:\n\t\t\t\t\tvar distanceY = initialTouchY - currentTouchY;\n\t\t\t\t\tvar distanceX = initialTouchX - currentTouchX;\n\t\t\t\t\tvar distance2 = distanceX * distanceX + distanceY * distanceY;\n\n\t\t\t\t\t//Check if it was more like a tap (moved less than 7px).\n\t\t\t\t\tif(distance2 < 49) {\n\t\t\t\t\t\tif(!rxTouchIgnoreTags.test(initialElement.tagName)) {\n\t\t\t\t\t\t\tinitialElement.focus();\n\n\t\t\t\t\t\t\t//It was a tap, click the element.\n\t\t\t\t\t\t\tvar clickEvent = document.createEvent('MouseEvents');\n\t\t\t\t\t\t\tclickEvent.initMouseEvent('click', true, true, e.view, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);\n\t\t\t\t\t\t\tinitialElement.dispatchEvent(clickEvent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitialElement = undefined;\n\n\t\t\t\t\tvar speed = deltaY / deltaTime;\n\n\t\t\t\t\t//Cap speed at 3 pixel/ms.\n\t\t\t\t\tspeed = Math.max(Math.min(speed, 3), -3);\n\n\t\t\t\t\tvar duration = Math.abs(speed / _mobileDeceleration);\n\t\t\t\t\tvar targetOffset = speed * duration + 0.5 * _mobileDeceleration * duration * duration;\n\t\t\t\t\tvar targetTop = _instance.getScrollTop() - targetOffset;\n\n\t\t\t\t\t//Relative duration change for when scrolling above bounds.\n\t\t\t\t\tvar targetRatio = 0;\n\n\t\t\t\t\t//Change duration proportionally when scrolling would leave bounds.\n\t\t\t\t\tif(targetTop > _maxKeyFrame) {\n\t\t\t\t\t\ttargetRatio = (_maxKeyFrame - targetTop) / targetOffset;\n\n\t\t\t\t\t\ttargetTop = _maxKeyFrame;\n\t\t\t\t\t} else if(targetTop < 0) {\n\t\t\t\t\t\ttargetRatio = -targetTop / targetOffset;\n\n\t\t\t\t\t\ttargetTop = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = duration * (1 - targetRatio);\n\n\t\t\t\t\t_instance.animateTo((targetTop + 0.5) | 0, {easing: 'outCubic', duration: duration});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\t//Just in case there has already been some native scrolling, reset it.\n\t\twindow.scrollTo(0, 0);\n\t\tdocumentElement.style.overflow = body.style.overflow = 'hidden';\n\t};\n\n\t/**\n\t * Updates key frames which depend on others / need to be updated on resize.\n\t * That is \"end\" in \"absolute\" mode and all key frames in \"relative\" mode.\n\t * Also handles constants, because they may change on resize.\n\t */\n\tvar _updateDependentKeyFrames = function() {\n\t\tvar viewportHeight = documentElement.clientHeight;\n\t\tvar processedConstants = _processConstants();\n\t\tvar skrollable;\n\t\tvar element;\n\t\tvar anchorTarget;\n\t\tvar keyFrames;\n\t\tvar keyFrameIndex;\n\t\tvar keyFramesLength;\n\t\tvar kf;\n\t\tvar skrollableIndex;\n\t\tvar skrollablesLength;\n\t\tvar offset;\n\t\tvar constantValue;\n\n\t\t//First process all relative-mode elements and find the max key frame.\n\t\tskrollableIndex = 0;\n\t\tskrollablesLength = _skrollables.length;\n\n\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {\n\t\t\tskrollable = _skrollables[skrollableIndex];\n\t\t\telement = skrollable.element;\n\t\t\tanchorTarget = skrollable.anchorTarget;\n\t\t\tkeyFrames = skrollable.keyFrames;\n\n\t\t\tkeyFrameIndex = 0;\n\t\t\tkeyFramesLength = keyFrames.length;\n\n\t\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n\t\t\t\tkf = keyFrames[keyFrameIndex];\n\n\t\t\t\toffset = kf.offset;\n\t\t\t\tconstantValue = processedConstants[kf.constant] || 0;\n\n\t\t\t\tkf.frame = offset;\n\n\t\t\t\tif(kf.isPercentage) {\n\t\t\t\t\t//Convert the offset to percentage of the viewport height.\n\t\t\t\t\toffset = offset * viewportHeight;\n\n\t\t\t\t\t//Absolute + percentage mode.\n\t\t\t\t\tkf.frame = offset;\n\t\t\t\t}\n\n\t\t\t\tif(kf.mode === 'relative') {\n\t\t\t\t\t_reset(element);\n\n\t\t\t\t\tkf.frame = _instance.relativeToAbsolute(anchorTarget, kf.anchors[0], kf.anchors[1]) - offset;\n\n\t\t\t\t\t_reset(element, true);\n\t\t\t\t}\n\n\t\t\t\tkf.frame += constantValue;\n\n\t\t\t\t//Only search for max key frame when forceHeight is enabled.\n\t\t\t\tif(_forceHeight) {\n\t\t\t\t\t//Find the max key frame, but don't use one of the data-end ones for comparison.\n\t\t\t\t\tif(!kf.isEnd && kf.frame > _maxKeyFrame) {\n\t\t\t\t\t\t_maxKeyFrame = kf.frame;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//#133: The document can be larger than the maxKeyFrame we found.\n\t\t_maxKeyFrame = Math.max(_maxKeyFrame, _getDocumentHeight());\n\n\t\t//Now process all data-end keyframes.\n\t\tskrollableIndex = 0;\n\t\tskrollablesLength = _skrollables.length;\n\n\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {\n\t\t\tskrollable = _skrollables[skrollableIndex];\n\t\t\tkeyFrames = skrollable.keyFrames;\n\n\t\t\tkeyFrameIndex = 0;\n\t\t\tkeyFramesLength = keyFrames.length;\n\n\t\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n\t\t\t\tkf = keyFrames[keyFrameIndex];\n\n\t\t\t\tconstantValue = processedConstants[kf.constant] || 0;\n\n\t\t\t\tif(kf.isEnd) {\n\t\t\t\t\tkf.frame = _maxKeyFrame - kf.offset + constantValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tskrollable.keyFrames.sort(_keyFrameComparator);\n\t\t}\n\t};\n\n\t/**\n\t * Calculates and sets the style properties for the element at the given frame.\n\t * @param fakeFrame The frame to render at when smooth scrolling is enabled.\n\t * @param actualFrame The actual frame we are at.\n\t */\n\tvar _calcSteps = function(fakeFrame, actualFrame) {\n\t\t//Iterate over all skrollables.\n\t\tvar skrollableIndex = 0;\n\t\tvar skrollablesLength = _skrollables.length;\n\n\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {\n\t\t\tvar skrollable = _skrollables[skrollableIndex];\n\t\t\tvar element = skrollable.element;\n\t\t\tvar frame = skrollable.smoothScrolling ? fakeFrame : actualFrame;\n\t\t\tvar frames = skrollable.keyFrames;\n\t\t\tvar framesLength = frames.length;\n\t\t\tvar firstFrame = frames[0];\n\t\t\tvar lastFrame = frames[frames.length - 1];\n\t\t\tvar beforeFirst = frame < firstFrame.frame;\n\t\t\tvar afterLast = frame > lastFrame.frame;\n\t\t\tvar firstOrLastFrame = beforeFirst ? firstFrame : lastFrame;\n\t\t\tvar emitEvents = skrollable.emitEvents;\n\t\t\tvar lastFrameIndex = skrollable.lastFrameIndex;\n\t\t\tvar key;\n\t\t\tvar value;\n\n\t\t\t//If we are before/after the first/last frame, set the styles according to the given edge strategy.\n\t\t\tif(beforeFirst || afterLast) {\n\t\t\t\t//Check if we already handled this edge case last time.\n\t\t\t\t//Note: using setScrollTop it's possible that we jumped from one edge to the other.\n\t\t\t\tif(beforeFirst && skrollable.edge === -1 || afterLast && skrollable.edge === 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Add the skrollr-before or -after class.\n\t\t\t\tif(beforeFirst) {\n\t\t\t\t\t_updateClass(element, [SKROLLABLE_BEFORE_CLASS], [SKROLLABLE_AFTER_CLASS, SKROLLABLE_BETWEEN_CLASS]);\n\n\t\t\t\t\t//This handles the special case where we exit the first keyframe.\n\t\t\t\t\tif(emitEvents && lastFrameIndex > -1) {\n\t\t\t\t\t\t_emitEvent(element, firstFrame.eventType, _direction);\n\t\t\t\t\t\tskrollable.lastFrameIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t_updateClass(element, [SKROLLABLE_AFTER_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_BETWEEN_CLASS]);\n\n\t\t\t\t\t//This handles the special case where we exit the last keyframe.\n\t\t\t\t\tif(emitEvents && lastFrameIndex < framesLength) {\n\t\t\t\t\t\t_emitEvent(element, lastFrame.eventType, _direction);\n\t\t\t\t\t\tskrollable.lastFrameIndex = framesLength;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Remember that we handled the edge case (before/after the first/last keyframe).\n\t\t\t\tskrollable.edge = beforeFirst ? -1 : 1;\n\n\t\t\t\tswitch(skrollable.edgeStrategy) {\n\t\t\t\t\tcase 'reset':\n\t\t\t\t\t\t_reset(element);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase 'ease':\n\t\t\t\t\t\t//Handle this case like it would be exactly at first/last keyframe and just pass it on.\n\t\t\t\t\t\tframe = firstOrLastFrame.frame;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\tvar props = firstOrLastFrame.props;\n\n\t\t\t\t\t\tfor(key in props) {\n\t\t\t\t\t\t\tif(hasProp.call(props, key)) {\n\t\t\t\t\t\t\t\tvalue = _interpolateString(props[key].value);\n\n\t\t\t\t\t\t\t\t//Set style or attribute.\n\t\t\t\t\t\t\t\tif(key.indexOf('@') === 0) {\n\t\t\t\t\t\t\t\t\telement.setAttribute(key.substr(1), value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tskrollr.setStyle(element, key, value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Did we handle an edge last time?\n\t\t\t\tif(skrollable.edge !== 0) {\n\t\t\t\t\t_updateClass(element, [SKROLLABLE_CLASS, SKROLLABLE_BETWEEN_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_AFTER_CLASS]);\n\t\t\t\t\tskrollable.edge = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Find out between which two key frames we are right now.\n\t\t\tvar keyFrameIndex = 0;\n\n\t\t\tfor(; keyFrameIndex < framesLength - 1; keyFrameIndex++) {\n\t\t\t\tif(frame >= frames[keyFrameIndex].frame && frame <= frames[keyFrameIndex + 1].frame) {\n\t\t\t\t\tvar left = frames[keyFrameIndex];\n\t\t\t\t\tvar right = frames[keyFrameIndex + 1];\n\n\t\t\t\t\tfor(key in left.props) {\n\t\t\t\t\t\tif(hasProp.call(left.props, key)) {\n\t\t\t\t\t\t\tvar progress = (frame - left.frame) / (right.frame - left.frame);\n\n\t\t\t\t\t\t\t//Transform the current progress using the given easing function.\n\t\t\t\t\t\t\tprogress = left.props[key].easing(progress);\n\n\t\t\t\t\t\t\t//Interpolate between the two values\n\t\t\t\t\t\t\tvalue = _calcInterpolation(left.props[key].value, right.props[key].value, progress);\n\n\t\t\t\t\t\t\tvalue = _interpolateString(value);\n\n\t\t\t\t\t\t\t//Set style or attribute.\n\t\t\t\t\t\t\tif(key.indexOf('@') === 0) {\n\t\t\t\t\t\t\t\telement.setAttribute(key.substr(1), value);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tskrollr.setStyle(element, key, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//Are events enabled on this element?\n\t\t\t\t\t//This code handles the usual cases of scrolling through different keyframes.\n\t\t\t\t\t//The special cases of before first and after last keyframe are handled above.\n\t\t\t\t\tif(emitEvents) {\n\t\t\t\t\t\t//Did we pass a new keyframe?\n\t\t\t\t\t\tif(lastFrameIndex !== keyFrameIndex) {\n\t\t\t\t\t\t\tif(_direction === 'down') {\n\t\t\t\t\t\t\t\t_emitEvent(element, left.eventType, _direction);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_emitEvent(element, right.eventType, _direction);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tskrollable.lastFrameIndex = keyFrameIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Renders all elements.\n\t */\n\tvar _render = function() {\n\t\tif(_requestReflow) {\n\t\t\t_requestReflow = false;\n\t\t\t_reflow();\n\t\t}\n\n\t\t//We may render something else than the actual scrollbar position.\n\t\tvar renderTop = _instance.getScrollTop();\n\n\t\t//If there's an animation, which ends in current render call, call the callback after rendering.\n\t\tvar afterAnimationCallback;\n\t\tvar now = _now();\n\t\tvar progress;\n\n\t\t//Before actually rendering handle the scroll animation, if any.\n\t\tif(_scrollAnimation) {\n\t\t\t//It's over\n\t\t\tif(now >= _scrollAnimation.endTime) {\n\t\t\t\trenderTop = _scrollAnimation.targetTop;\n\t\t\t\tafterAnimationCallback = _scrollAnimation.done;\n\t\t\t\t_scrollAnimation = undefined;\n\t\t\t} else {\n\t\t\t\t//Map the current progress to the new progress using given easing function.\n\t\t\t\tprogress = _scrollAnimation.easing((now - _scrollAnimation.startTime) / _scrollAnimation.duration);\n\n\t\t\t\trenderTop = (_scrollAnimation.startTop + progress * _scrollAnimation.topDiff) | 0;\n\t\t\t}\n\n\t\t\t_instance.setScrollTop(renderTop, true);\n\t\t}\n\t\t//Smooth scrolling only if there's no animation running and if we're not forcing the rendering.\n\t\telse if(!_forceRender) {\n\t\t\tvar smoothScrollingDiff = _smoothScrolling.targetTop - renderTop;\n\n\t\t\t//The user scrolled, start new smooth scrolling.\n\t\t\tif(smoothScrollingDiff) {\n\t\t\t\t_smoothScrolling = {\n\t\t\t\t\tstartTop: _lastTop,\n\t\t\t\t\ttopDiff: renderTop - _lastTop,\n\t\t\t\t\ttargetTop: renderTop,\n\t\t\t\t\tstartTime: _lastRenderCall,\n\t\t\t\t\tendTime: _lastRenderCall + _smoothScrollingDuration\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//Interpolate the internal scroll position (not the actual scrollbar).\n\t\t\tif(now <= _smoothScrolling.endTime) {\n\t\t\t\t//Map the current progress to the new progress using easing function.\n\t\t\t\tprogress = easings.sqrt((now - _smoothScrolling.startTime) / _smoothScrollingDuration);\n\n\t\t\t\trenderTop = (_smoothScrolling.startTop + progress * _smoothScrolling.topDiff) | 0;\n\t\t\t}\n\t\t}\n\n\t\t//Did the scroll position even change?\n\t\tif(_forceRender || _lastTop !== renderTop) {\n\t\t\t//Remember in which direction are we scrolling?\n\t\t\t_direction = (renderTop > _lastTop) ? 'down' : (renderTop < _lastTop ? 'up' : _direction);\n\n\t\t\t_forceRender = false;\n\n\t\t\tvar listenerParams = {\n\t\t\t\tcurTop: renderTop,\n\t\t\t\tlastTop: _lastTop,\n\t\t\t\tmaxTop: _maxKeyFrame,\n\t\t\t\tdirection: _direction\n\t\t\t};\n\n\t\t\t//Tell the listener we are about to render.\n\t\t\tvar continueRendering = _listeners.beforerender && _listeners.beforerender.call(_instance, listenerParams);\n\n\t\t\t//The beforerender listener function is able the cancel rendering.\n\t\t\tif(continueRendering !== false) {\n\t\t\t\t//Now actually interpolate all the styles.\n\t\t\t\t_calcSteps(renderTop, _instance.getScrollTop());\n\n\t\t\t\t//That's were we actually \"scroll\" on mobile.\n\t\t\t\tif(_isMobile && _skrollrBody) {\n\t\t\t\t\t//Set the transform (\"scroll it\").\n\t\t\t\t\tskrollr.setStyle(_skrollrBody, 'transform', 'translate(0, ' + -(_mobileOffset) + 'px) ' + _translateZ);\n\t\t\t\t}\n\n\t\t\t\t//Remember when we last rendered.\n\t\t\t\t_lastTop = renderTop;\n\n\t\t\t\tif(_listeners.render) {\n\t\t\t\t\t_listeners.render.call(_instance, listenerParams);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(afterAnimationCallback) {\n\t\t\t\tafterAnimationCallback.call(_instance, false);\n\t\t\t}\n\t\t}\n\n\t\t_lastRenderCall = now;\n\t};\n\n\t/**\n\t * Parses the properties for each key frame of the given skrollable.\n\t */\n\tvar _parseProps = function(skrollable) {\n\t\t//Iterate over all key frames\n\t\tvar keyFrameIndex = 0;\n\t\tvar keyFramesLength = skrollable.keyFrames.length;\n\n\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n\t\t\tvar frame = skrollable.keyFrames[keyFrameIndex];\n\t\t\tvar easing;\n\t\t\tvar value;\n\t\t\tvar prop;\n\t\t\tvar props = {};\n\n\t\t\tvar match;\n\n\t\t\twhile((match = rxPropValue.exec(frame.props)) !== null) {\n\t\t\t\tprop = match[1];\n\t\t\t\tvalue = match[2];\n\n\t\t\t\teasing = prop.match(rxPropEasing);\n\n\t\t\t\t//Is there an easing specified for this prop?\n\t\t\t\tif(easing !== null) {\n\t\t\t\t\tprop = easing[1];\n\t\t\t\t\teasing = easing[2];\n\t\t\t\t} else {\n\t\t\t\t\teasing = DEFAULT_EASING;\n\t\t\t\t}\n\n\t\t\t\t//Exclamation point at first position forces the value to be taken literal.\n\t\t\t\tvalue = value.indexOf('!') ? _parseProp(value) : [value.slice(1)];\n\n\t\t\t\t//Save the prop for this key frame with his value and easing function\n\t\t\t\tprops[prop] = {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\teasing: easings[easing]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tframe.props = props;\n\t\t}\n\t};\n\n\t/**\n\t * Parses a value extracting numeric values and generating a format string\n\t * for later interpolation of the new values in old string.\n\t *\n\t * @param val The CSS value to be parsed.\n\t * @return Something like [\"rgba(?%,?%, ?%,?)\", 100, 50, 0, .7]\n\t * where the first element is the format string later used\n\t * and all following elements are the numeric value.\n\t */\n\tvar _parseProp = function(val) {\n\t\tvar numbers = [];\n\n\t\t//One special case, where floats don't work.\n\t\t//We replace all occurences of rgba colors\n\t\t//which don't use percentage notation with the percentage notation.\n\t\trxRGBAIntegerColor.lastIndex = 0;\n\t\tval = val.replace(rxRGBAIntegerColor, function(rgba) {\n\t\t\treturn rgba.replace(rxNumericValue, function(n) {\n\t\t\t\treturn n / 255 * 100 + '%';\n\t\t\t});\n\t\t});\n\n\t\t//Handle prefixing of \"gradient\" values.\n\t\t//For now only the prefixed value will be set. Unprefixed isn't supported anyway.\n\t\tif(theDashedCSSPrefix) {\n\t\t\trxGradient.lastIndex = 0;\n\t\t\tval = val.replace(rxGradient, function(s) {\n\t\t\t\treturn theDashedCSSPrefix + s;\n\t\t\t});\n\t\t}\n\n\t\t//Now parse ANY number inside this string and create a format string.\n\t\tval = val.replace(rxNumericValue, function(n) {\n\t\t\tnumbers.push(+n);\n\t\t\treturn '{?}';\n\t\t});\n\n\t\t//Add the formatstring as first value.\n\t\tnumbers.unshift(val);\n\n\t\treturn numbers;\n\t};\n\n\t/**\n\t * Fills the key frames with missing left and right hand properties.\n\t * If key frame 1 has property X and key frame 2 is missing X,\n\t * but key frame 3 has X again, then we need to assign X to key frame 2 too.\n\t *\n\t * @param sk A skrollable.\n\t */\n\tvar _fillProps = function(sk) {\n\t\t//Will collect the properties key frame by key frame\n\t\tvar propList = {};\n\t\tvar keyFrameIndex;\n\t\tvar keyFramesLength;\n\n\t\t//Iterate over all key frames from left to right\n\t\tkeyFrameIndex = 0;\n\t\tkeyFramesLength = sk.keyFrames.length;\n\n\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n\t\t\t_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);\n\t\t}\n\n\t\t//Now do the same from right to fill the last gaps\n\n\t\tpropList = {};\n\n\t\t//Iterate over all key frames from right to left\n\t\tkeyFrameIndex = sk.keyFrames.length - 1;\n\n\t\tfor(; keyFrameIndex >= 0; keyFrameIndex--) {\n\t\t\t_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);\n\t\t}\n\t};\n\n\tvar _fillPropForFrame = function(frame, propList) {\n\t\tvar key;\n\n\t\t//For each key frame iterate over all right hand properties and assign them,\n\t\t//but only if the current key frame doesn't have the property by itself\n\t\tfor(key in propList) {\n\t\t\t//The current frame misses this property, so assign it.\n\t\t\tif(!hasProp.call(frame.props, key)) {\n\t\t\t\tframe.props[key] = propList[key];\n\t\t\t}\n\t\t}\n\n\t\t//Iterate over all props of the current frame and collect them\n\t\tfor(key in frame.props) {\n\t\t\tpropList[key] = frame.props[key];\n\t\t}\n\t};\n\n\t/**\n\t * Calculates the new values for two given values array.\n\t */\n\tvar _calcInterpolation = function(val1, val2, progress) {\n\t\tvar valueIndex;\n\t\tvar val1Length = val1.length;\n\n\t\t//They both need to have the same length\n\t\tif(val1Length !== val2.length) {\n\t\t\tthrow 'Can\\'t interpolate between \"' + val1[0] + '\" and \"' + val2[0] + '\"';\n\t\t}\n\n\t\t//Add the format string as first element.\n\t\tvar interpolated = [val1[0]];\n\n\t\tvalueIndex = 1;\n\n\t\tfor(; valueIndex < val1Length; valueIndex++) {\n\t\t\t//That's the line where the two numbers are actually interpolated.\n\t\t\tinterpolated[valueIndex] = val1[valueIndex] + ((val2[valueIndex] - val1[valueIndex]) * progress);\n\t\t}\n\n\t\treturn interpolated;\n\t};\n\n\t/**\n\t * Interpolates the numeric values into the format string.\n\t */\n\tvar _interpolateString = function(val) {\n\t\tvar valueIndex = 1;\n\n\t\trxInterpolateString.lastIndex = 0;\n\n\t\treturn val[0].replace(rxInterpolateString, function() {\n\t\t\treturn val[valueIndex++];\n\t\t});\n\t};\n\n\t/**\n\t * Resets the class and style attribute to what it was before skrollr manipulated the element.\n\t * Also remembers the values it had before reseting, in order to undo the reset.\n\t */\n\tvar _reset = function(elements, undo) {\n\t\t//We accept a single element or an array of elements.\n\t\telements = [].concat(elements);\n\n\t\tvar skrollable;\n\t\tvar element;\n\t\tvar elementsIndex = 0;\n\t\tvar elementsLength = elements.length;\n\n\t\tfor(; elementsIndex < elementsLength; elementsIndex++) {\n\t\t\telement = elements[elementsIndex];\n\t\t\tskrollable = _skrollables[element[SKROLLABLE_ID_DOM_PROPERTY]];\n\n\t\t\t//Couldn't find the skrollable for this DOM element.\n\t\t\tif(!skrollable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(undo) {\n\t\t\t\t//Reset class and style to the \"dirty\" (set by skrollr) values.\n\t\t\t\telement.style.cssText = skrollable.dirtyStyleAttr;\n\t\t\t\t_updateClass(element, skrollable.dirtyClassAttr);\n\t\t\t} else {\n\t\t\t\t//Remember the \"dirty\" (set by skrollr) class and style.\n\t\t\t\tskrollable.dirtyStyleAttr = element.style.cssText;\n\t\t\t\tskrollable.dirtyClassAttr = _getClass(element);\n\n\t\t\t\t//Reset class and style to what it originally was.\n\t\t\t\telement.style.cssText = skrollable.styleAttr;\n\t\t\t\t_updateClass(element, skrollable.classAttr);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Detects support for 3d transforms by applying it to the skrollr-body.\n\t */\n\tvar _detect3DTransforms = function() {\n\t\t_translateZ = 'translateZ(0)';\n\t\tskrollr.setStyle(_skrollrBody, 'transform', _translateZ);\n\n\t\tvar computedStyle = getStyle(_skrollrBody);\n\t\tvar computedTransform = computedStyle.getPropertyValue('transform');\n\t\tvar computedTransformWithPrefix = computedStyle.getPropertyValue(theDashedCSSPrefix + 'transform');\n\t\tvar has3D = (computedTransform && computedTransform !== 'none') || (computedTransformWithPrefix && computedTransformWithPrefix !== 'none');\n\n\t\tif(!has3D) {\n\t\t\t_translateZ = '';\n\t\t}\n\t};\n\n\t/**\n\t * Set the CSS property on the given element. Sets prefixed properties as well.\n\t */\n\tskrollr.setStyle = function(el, prop, val) {\n\t\tvar style = el.style;\n\n\t\t//Camel case.\n\t\tprop = prop.replace(rxCamelCase, rxCamelCaseFn).replace('-', '');\n\n\t\t//Make sure z-index gets a <integer>.\n\t\t//This is the only <integer> case we need to handle.\n\t\tif(prop === 'zIndex') {\n\t\t\tif(isNaN(val)) {\n\t\t\t\t//If it's not a number, don't touch it.\n\t\t\t\t//It could for example be \"auto\" (#351).\n\t\t\t\tstyle[prop] = val;\n\t\t\t} else {\n\t\t\t\t//Floor the number.\n\t\t\t\tstyle[prop] = '' + (val | 0);\n\t\t\t}\n\t\t}\n\t\t//#64: \"float\" can't be set across browsers. Needs to use \"cssFloat\" for all except IE.\n\t\telse if(prop === 'float') {\n\t\t\tstyle.styleFloat = style.cssFloat = val;\n\t\t}\n\t\telse {\n\t\t\t//Need try-catch for old IE.\n\t\t\ttry {\n\t\t\t\t//Set prefixed property if there's a prefix.\n\t\t\t\tif(theCSSPrefix) {\n\t\t\t\t\tstyle[theCSSPrefix + prop.slice(0,1).toUpperCase() + prop.slice(1)] = val;\n\t\t\t\t}\n\n\t\t\t\t//Set unprefixed.\n\t\t\t\tstyle[prop] = val;\n\t\t\t} catch(ignore) {}\n\t\t}\n\t};\n\n\t/**\n\t * Cross browser event handling.\n\t */\n\tvar _addEvent = skrollr.addEvent = function(element, names, callback) {\n\t\tvar intermediate = function(e) {\n\t\t\t//Normalize IE event stuff.\n\t\t\te = e || window.event;\n\n\t\t\tif(!e.target) {\n\t\t\t\te.target = e.srcElement;\n\t\t\t}\n\n\t\t\tif(!e.preventDefault) {\n\t\t\t\te.preventDefault = function() {\n\t\t\t\t\te.returnValue = false;\n\t\t\t\t\te.defaultPrevented = true;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn callback.call(this, e);\n\t\t};\n\n\t\tnames = names.split(' ');\n\n\t\tvar name;\n\t\tvar nameCounter = 0;\n\t\tvar namesLength = names.length;\n\n\t\tfor(; nameCounter < namesLength; nameCounter++) {\n\t\t\tname = names[nameCounter];\n\n\t\t\tif(element.addEventListener) {\n\t\t\t\telement.addEventListener(name, callback, false);\n\t\t\t} else {\n\t\t\t\telement.attachEvent('on' + name, intermediate);\n\t\t\t}\n\n\t\t\t//Remember the events to be able to flush them later.\n\t\t\t_registeredEvents.push({\n\t\t\t\telement: element,\n\t\t\t\tname: name,\n\t\t\t\tlistener: callback\n\t\t\t});\n\t\t}\n\t};\n\n\tvar _removeEvent = skrollr.removeEvent = function(element, names, callback) {\n\t\tnames = names.split(' ');\n\n\t\tvar nameCounter = 0;\n\t\tvar namesLength = names.length;\n\n\t\tfor(; nameCounter < namesLength; nameCounter++) {\n\t\t\tif(element.removeEventListener) {\n\t\t\t\telement.removeEventListener(names[nameCounter], callback, false);\n\t\t\t} else {\n\t\t\t\telement.detachEvent('on' + names[nameCounter], callback);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar _removeAllEvents = function() {\n\t\tvar eventData;\n\t\tvar eventCounter = 0;\n\t\tvar eventsLength = _registeredEvents.length;\n\n\t\tfor(; eventCounter < eventsLength; eventCounter++) {\n\t\t\teventData = _registeredEvents[eventCounter];\n\n\t\t\t_removeEvent(eventData.element, eventData.name, eventData.listener);\n\t\t}\n\n\t\t_registeredEvents = [];\n\t};\n\n\tvar _emitEvent = function(element, name, direction) {\n\t\tif(_listeners.keyframe) {\n\t\t\t_listeners.keyframe.call(_instance, element, name, direction);\n\t\t}\n\t};\n\n\tvar _reflow = function() {\n\t\tvar pos = _instance.getScrollTop();\n\n\t\t//Will be recalculated by _updateDependentKeyFrames.\n\t\t_maxKeyFrame = 0;\n\n\t\tif(_forceHeight && !_isMobile) {\n\t\t\t//un-\"force\" the height to not mess with the calculations in _updateDependentKeyFrames (#216).\n\t\t\tbody.style.height = '';\n\t\t}\n\n\t\t_updateDependentKeyFrames();\n\n\t\tif(_forceHeight && !_isMobile) {\n\t\t\t//\"force\" the height.\n\t\t\tbody.style.height = (_maxKeyFrame + documentElement.clientHeight) + 'px';\n\t\t}\n\n\t\t//The scroll offset may now be larger than needed (on desktop the browser/os prevents scrolling farther than the bottom).\n\t\tif(_isMobile) {\n\t\t\t_instance.setScrollTop(Math.min(_instance.getScrollTop(), _maxKeyFrame));\n\t\t} else {\n\t\t\t//Remember and reset the scroll pos (#217).\n\t\t\t_instance.setScrollTop(pos, true);\n\t\t}\n\n\t\t_forceRender = true;\n\t};\n\n\t/*\n\t * Returns a copy of the constants object where all functions and strings have been evaluated.\n\t */\n\tvar _processConstants = function() {\n\t\tvar viewportHeight = documentElement.clientHeight;\n\t\tvar copy = {};\n\t\tvar prop;\n\t\tvar value;\n\n\t\tfor(prop in _constants) {\n\t\t\tvalue = _constants[prop];\n\n\t\t\tif(typeof value === 'function') {\n\t\t\t\tvalue = value.call(_instance);\n\t\t\t}\n\t\t\t//Percentage offset.\n\t\t\telse if((/p$/).test(value)) {\n\t\t\t\tvalue = (value.slice(0, -1) / 100) * viewportHeight;\n\t\t\t}\n\n\t\t\tcopy[prop] = value;\n\t\t}\n\n\t\treturn copy;\n\t};\n\n\t/*\n\t * Returns the height of the document.\n\t */\n\tvar _getDocumentHeight = function() {\n\t\tvar skrollrBodyHeight = 0;\n\t\tvar bodyHeight;\n\n\t\tif(_skrollrBody) {\n\t\t\tskrollrBodyHeight = Math.max(_skrollrBody.offsetHeight, _skrollrBody.scrollHeight);\n\t\t}\n\n\t\tbodyHeight = Math.max(skrollrBodyHeight, body.scrollHeight, body.offsetHeight, documentElement.scrollHeight, documentElement.offsetHeight, documentElement.clientHeight);\n\n\t\treturn bodyHeight - documentElement.clientHeight;\n\t};\n\n\t/**\n\t * Returns a string of space separated classnames for the current element.\n\t * Works with SVG as well.\n\t */\n\tvar _getClass = function(element) {\n\t\tvar prop = 'className';\n\n\t\t//SVG support by using className.baseVal instead of just className.\n\t\tif(window.SVGElement && element instanceof window.SVGElement) {\n\t\t\telement = element[prop];\n\t\t\tprop = 'baseVal';\n\t\t}\n\n\t\treturn element[prop];\n\t};\n\n\t/**\n\t * Adds and removes a CSS classes.\n\t * Works with SVG as well.\n\t * add and remove are arrays of strings,\n\t * or if remove is ommited add is a string and overwrites all classes.\n\t */\n\tvar _updateClass = function(element, add, remove) {\n\t\tvar prop = 'className';\n\n\t\t//SVG support by using className.baseVal instead of just className.\n\t\tif(window.SVGElement && element instanceof window.SVGElement) {\n\t\t\telement = element[prop];\n\t\t\tprop = 'baseVal';\n\t\t}\n\n\t\t//When remove is ommited, we want to overwrite/set the classes.\n\t\tif(remove === undefined) {\n\t\t\telement[prop] = add;\n\t\t\treturn;\n\t\t}\n\n\t\t//Cache current classes. We will work on a string before passing back to DOM.\n\t\tvar val = element[prop];\n\n\t\t//All classes to be removed.\n\t\tvar classRemoveIndex = 0;\n\t\tvar removeLength = remove.length;\n\n\t\tfor(; classRemoveIndex < removeLength; classRemoveIndex++) {\n\t\t\tval = _untrim(val).replace(_untrim(remove[classRemoveIndex]), ' ');\n\t\t}\n\n\t\tval = _trim(val);\n\n\t\t//All classes to be added.\n\t\tvar classAddIndex = 0;\n\t\tvar addLength = add.length;\n\n\t\tfor(; classAddIndex < addLength; classAddIndex++) {\n\t\t\t//Only add if el not already has class.\n\t\t\tif(_untrim(val).indexOf(_untrim(add[classAddIndex])) === -1) {\n\t\t\t\tval += ' ' + add[classAddIndex];\n\t\t\t}\n\t\t}\n\n\t\telement[prop] = _trim(val);\n\t};\n\n\tvar _trim = function(a) {\n\t\treturn a.replace(rxTrim, '');\n\t};\n\n\t/**\n\t * Adds a space before and after the string.\n\t */\n\tvar _untrim = function(a) {\n\t\treturn ' ' + a + ' ';\n\t};\n\n\tvar _now = Date.now || function() {\n\t\treturn +new Date();\n\t};\n\n\tvar _keyFrameComparator = function(a, b) {\n\t\treturn a.frame - b.frame;\n\t};\n\n\t/*\n\t * Private variables.\n\t */\n\n\t//Singleton\n\tvar _instance;\n\n\t/*\n\t\tA list of all elements which should be animated associated with their the metadata.\n\t\tExmaple skrollable with two key frames animating from 100px width to 20px:\n\n\t\tskrollable = {\n\t\t\telement: <the DOM element>,\n\t\t\tstyleAttr: <style attribute of the element before skrollr>,\n\t\t\tclassAttr: <class attribute of the element before skrollr>,\n\t\t\tkeyFrames: [\n\t\t\t\t{\n\t\t\t\t\tframe: 100,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\twidth: {\n\t\t\t\t\t\t\tvalue: ['{?}px', 100],\n\t\t\t\t\t\t\teasing: <reference to easing function>\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmode: \"absolute\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tframe: 200,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\twidth: {\n\t\t\t\t\t\t\tvalue: ['{?}px', 20],\n\t\t\t\t\t\t\teasing: <reference to easing function>\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmode: \"absolute\"\n\t\t\t\t}\n\t\t\t]\n\t\t};\n\t*/\n\tvar _skrollables;\n\n\tvar _skrollrBody;\n\n\tvar _listeners;\n\tvar _forceHeight;\n\tvar _maxKeyFrame = 0;\n\n\tvar _scale = 1;\n\tvar _constants;\n\n\tvar _mobileDeceleration;\n\n\t//Current direction (up/down).\n\tvar _direction = 'down';\n\n\t//The last top offset value. Needed to determine direction.\n\tvar _lastTop = -1;\n\n\t//The last time we called the render method (doesn't mean we rendered!).\n\tvar _lastRenderCall = _now();\n\n\t//For detecting if it actually resized (#271).\n\tvar _lastViewportWidth = 0;\n\tvar _lastViewportHeight = 0;\n\n\tvar _requestReflow = false;\n\n\t//Will contain data about a running scrollbar animation, if any.\n\tvar _scrollAnimation;\n\n\tvar _smoothScrollingEnabled;\n\n\tvar _smoothScrollingDuration;\n\n\t//Will contain settins for smooth scrolling if enabled.\n\tvar _smoothScrolling;\n\n\t//Can be set by any operation/event to force rendering even if the scrollbar didn't move.\n\tvar _forceRender;\n\n\t//Each skrollable gets an unique ID incremented for each skrollable.\n\t//The ID is the index in the _skrollables array.\n\tvar _skrollableIdCounter = 0;\n\n\tvar _edgeStrategy;\n\n\n\t//Mobile specific vars. Will be stripped by UglifyJS when not in use.\n\tvar _isMobile = false;\n\n\t//The virtual scroll offset when using mobile scrolling.\n\tvar _mobileOffset = 0;\n\n\t//If the browser supports 3d transforms, this will be filled with 'translateZ(0)' (empty string otherwise).\n\tvar _translateZ;\n\n\t//Will contain data about registered events by skrollr.\n\tvar _registeredEvents = [];\n\n\t//Animation frame id returned by RequestAnimationFrame (or timeout when RAF is not supported).\n\tvar _animFrame;\n\n\t//Expose skrollr as either a global variable or a require.js module.\n\t// if(typeof define === 'function' && define.amd) {\n\t// \tdefine([], function () {\n\t// \t\treturn skrollr;\n\t// \t});\n\t// } else if (typeof module !== 'undefined' && module.exports) {\n\t// \tmodule.exports = skrollr;\n\t// } else {\n\t// \twindow.skrollr = skrollr;\n\t// }\n\n}(window, document));\n"]},"metadata":{},"sourceType":"module"}